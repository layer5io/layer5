"use strict";(self.webpackChunkLayer5=self.webpackChunkLayer5||[]).push([[37409],{34184:function(e,n,t){t.r(n),t.d(n,{Head:function(){return p},default:function(){return d}});var l=t(28453),a=t(96540),o=t(44928);t(64810);function r(e){const n=Object.assign({p:"p",code:"code",strong:"strong",em:"em",h2:"h2",pre:"pre",ol:"ol",li:"li",h3:"h3",ul:"ul",a:"a"},(0,l.R)(),e.components);return a.createElement(o.C,null,a.createElement(n.p,null,"A common point of confusion when working with Kubernetes is understanding how ",a.createElement(n.code,null,"ConfigMap")," updates are handled. You‚Äôve pushed a change to your ConfigMap, but your application isn't seeing the new values. What's going on?"),a.createElement(n.p,null,"The answer depends entirely on ",a.createElement(n.strong,null,"how your application consumes the ConfigMap"),'. There isn\'t a "type" of ConfigMap object itself, but rather two distinct ',a.createElement(n.em,null,"methods of consumption")," by a Pod, and each has drastically different behavior regarding updates."),a.createElement(n.p,null,'To tell what "kind" you have, you need to look at your Pod or Deployment\'s YAML definition.'),a.createElement(n.h2,null,"How to Check Your Pod's ConfigMap Consumption"),a.createElement(n.p,null,"You can find out how a Pod is using a ConfigMap by inspecting its YAML definition. üßê  Run this command to get the running YAML for a specific pod:"),a.createElement(n.pre,null,a.createElement(n.code,{className:"language-bash"},"kubectl get pod <your-pod-name> -o yaml\n")),a.createElement(n.p,null,"Now, look for two key sections in the ",a.createElement(n.code,null,"spec.containers")," list:"),a.createElement(n.ol,null,"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Environment Variables:")," Look for ",a.createElement(n.code,null,"env")," or ",a.createElement(n.code,null,"envFrom"),"."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Mounted Volumes:")," Look for ",a.createElement(n.code,null,"volumeMounts")," and the corresponding ",a.createElement(n.code,null,"volumes")," section at the Pod spec level."),"\n"),a.createElement(n.p,null,"Let's break down what each one means for reloading."),a.createElement(n.h2,null,"1. Consumed as Environment Variables"),a.createElement(n.p,null,"This is when your Pod's YAML injects ConfigMap data directly as environment variables for the container."),a.createElement(n.h3,null,"How to Identify It"),a.createElement(n.p,null,"In your Pod spec, you'll see blocks like this:"),a.createElement(n.pre,null,a.createElement(n.code,{className:"language-yaml"},"# ...\nspec:\n  containers:\n  - name: my-app-container\n    image: my-app\n    env: # <-- Look here\n      - name: MY_CONFIG_KEY\n        valueFrom: # <-- Or here\n          configMapKeyRef:\n            name: my-special-config\n            key: some.config.key\n    envFrom: # <-- Or here\n      - configMapRef:\n          name: my-special-config\n# ...\n")),a.createElement(n.p,null,"If you see ",a.createElement(n.code,null,"env")," or ",a.createElement(n.code,null,"envFrom")," pointing to a ",a.createElement(n.code,null,"configMapKeyRef")," or ",a.createElement(n.code,null,"configMapRef"),", your application is consuming the ConfigMap as environment variables."),a.createElement(n.h3,null,"Reload Behavior: üõë No Hot-Reload"),a.createElement(n.p,null,"This is the most critical difference: ",a.createElement(n.strong,null,"Changes to a ConfigMap are NOT reflected in running Pods that use them as environment variables.")),a.createElement(n.p,null,"Environment variables are set by the container runtime ",a.createElement(n.em,null,"only when the container is created"),". They are immutable for the life of that running process."),a.createElement(n.p,null,a.createElement(n.strong,null,"How to Apply Changes:")," To make the application see the new ConfigMap values, you ",a.createElement(n.strong,null,"must restart the Pod"),". The simplest way to do this for a ",a.createElement(n.code,null,"Deployment")," is with a rolling restart:"),a.createElement(n.pre,null,a.createElement(n.code,{className:"language-bash"},"kubectl rollout restart deployment <your-deployment-name>\n")),a.createElement(n.p,null,"When the new Pods are created, they will read the ",a.createElement(n.em,null,"updated")," ConfigMap data and set the new environment variables."),a.createElement(n.h2,null,"2. Consumed as a Mounted Volume"),a.createElement(n.p,null,"This method mounts your ConfigMap as one or more files inside your Pod's filesystem. Your application is programmed to read its configuration from these files (e.g., ",a.createElement(n.code,null,"/app/config/settings.properties"),")."),a.createElement(n.h3,null,"How to Identify It"),a.createElement(n.p,null,"You'll see two corresponding sections in your Pod spec:"),a.createElement(n.ol,null,"\n",a.createElement(n.li,null,a.createElement(n.code,null,"spec.containers.volumeMounts"),": This tells the container where to mount the volume."),"\n",a.createElement(n.li,null,a.createElement(n.code,null,"spec.volumes"),": This defines the volume itself and links it to the ConfigMap."),"\n"),a.createElement(n.pre,null,a.createElement(n.code,{className:"language-yaml"},"# ...\nspec:\n  containers:\n  - name: my-app-container\n    image: my-app\n    volumeMounts: # <-- Look here\n    - name: config-volume\n      mountPath: /etc/config\n  volumes: # <-- And here\n  - name: config-volume\n    configMap:\n      name: my-special-config\n# ...\n")),a.createElement(n.p,null,"If you see this ",a.createElement(n.code,null,"volumes")," and ",a.createElement(n.code,null,"volumeMounts")," pairing, your application is consuming the ConfigMap as files."),a.createElement(n.h3,null,"Reload Behavior: ‚úÖ Automatic... With a Catch"),a.createElement(n.p,null,"This method ",a.createElement(n.strong,null,"does support hot-reloading"),", but with two important caveats:"),a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"There is a delay.")," When you update the ConfigMap object, the ",a.createElement(n.code,null,"kubelet")," on the node is responsible for updating the mounted files. This is not instantaneous. It relies on a periodic sync cycle, and the total delay can be ",a.createElement(n.strong,null,"60 to 90 seconds (or even longer)")," before the files at ",a.createElement(n.code,null,"mountPath")," are actually updated."),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Your application must support it.")," Kubernetes ",a.createElement(n.em,null,"only")," updates the files on disk. It does ",a.createElement(n.strong,null,"not")," send a signal (like ",a.createElement(n.code,null,"SIGHUP"),") to the process or restart the container. Your application must be built to:"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Watch the configuration files for changes (using a library like ",a.createElement(n.code,null,"fsnotify"),")."),"\n",a.createElement(n.li,null,"Periodically re-read the configuration files on its own timer."),"\n"),"\n"),"\n"),a.createElement(n.p,null,"If your application only reads its config files on startup, it will behave just like the environment variable method: ",a.createElement(n.strong,null,"it will not see the changes until it is restarted.")),a.createElement(n.h2,null,"ConfigMap Reload Behavior Summary"),a.createElement(n.p,null,"Here‚Äôs a simple table to remember the differences:"),a.createElement(n.p,null,"| Consumption Method | How to Identify in Pod YAML | Are Changes Updated in Running Pod? | How Are Changes Seen? |\n| :--- | :--- | :--- | :--- |\n| ",a.createElement(n.strong,null,"Environment Variables")," | ",a.createElement(n.code,null,"spec.containers.env")," ",a.createElement(n.code,null,"spec.containers.envFrom")," | ",a.createElement(n.strong,null,"No")," ‚ùå | Pod must be ",a.createElement(n.strong,null,"restarted"),". |\n| ",a.createElement(n.strong,null,"Mounted Volume")," | ",a.createElement(n.code,null,"spec.containers.volumeMounts")," ",a.createElement(n.code,null,"spec.volumes")," | ",a.createElement(n.strong,null,"Yes")," ‚úÖ (with delay) | Kubelet updates files. ",a.createElement(n.strong,null,"Application must be coded")," to reload the updated file. |"),a.createElement(n.h3,null,"What If I Need Automatic Restarts?"),a.createElement(n.p,null,'If you are using the volume mount method but your application doesn\'t support live reloading, you can use a "reloader" tool. A popular open-source controller like ',a.createElement(n.a,{href:"https://github.com/stakater/Reloader"},a.createElement(n.strong,null,"Stakater's Reloader"))," can watch for ConfigMap changes and automatically trigger a rolling restart of any Deployment that uses it. This gives you the best of both worlds: configuration in files and automatic updates for apps that can't reload on their own."),a.createElement("br"),a.createElement("hr"),a.createElement("br"),a.createElement(n.h2,null,"Skip the CLI. Power up with Kanvas"),a.createElement(n.p,null,"Alternatively, you can skip the YAML editing and make these changes visually. That is, if you're managing your Kubernetes cluster using Kanvas. Let's break down how to use it to manage your resources, like a ",a.createElement(n.code,null,"ConfigMap"),"."),a.createElement(n.h2,null,"ü§î What is Kanvas Designer?"),a.createElement(n.p,null,a.createElement(n.a,{href:"https://layer5.io/kanvas"},"Layer5's Kanvas")," is a powerful tool for designing, deploying, and managing your Kubernetes and Cloud infrastructure and workloads from a visual interface. Instead of writing hundreds of lines of YAML by hand, you build a ",a.createElement(n.strong,null,"Design"),". This design is a visual representation of your components (",a.createElement(n.code,null,"Deployment"),", ",a.createElement(n.code,null,"Service"),", ",a.createElement(n.code,null,"ConfigMap"),", etc.) and their relationships."),a.createElement(n.h2,null,"üé® How to Update a ConfigMap in Kanvas Designer"),a.createElement(n.p,null,"Updating a ",a.createElement(n.code,null,"ConfigMap"),' through the Designer follows this "design-first" workflow. You don\'t just "edit" the live resource in the cluster; you ',a.createElement(n.strong,null,"update your design")," and then ",a.createElement(n.strong,null,"(re-)deploy it"),"."),a.createElement(n.p,null,"Here is the step-by-step process:"),a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Open Kanvas Designer:")," Log in to your Kanvas UI and navigate to Designer mode (the default mode)."),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Load Your Design:")," Open the design file that contains the ",a.createElement(n.code,null,"ConfigMap")," you want to edit. If you don't have a design yet, you can import your existing ",a.createElement(n.code,null,"ConfigMap")," from your cluster directly onto the canvas."),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Find the ConfigMap Component:")," On the visual canvas, find the block representing your ",a.createElement(n.code,null,"ConfigMap"),'. It will have the Kubernetes icon and the "ConfigMap" kind.'),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Edit the Configuration:")," Click on the component. A configuration panel will slide out, often with a 'Configure' tab or an editor icon. This will show you the key/value pairs for that ",a.createElement(n.em,null,"specific")," ",a.createElement(n.code,null,"ConfigMap")," resource."),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Deploy the Design:")," Changes are automatically saved in your design as you make them. Use the ",a.createElement(n.strong,null,"Deploy"),' button to send your entire design to your target Kubernetes or Cloud environment. Kanvas will calculate the difference (a "diff") and apply the updated ',a.createElement(n.code,null,"ConfigMap")," manifest to your cluster. This action is the equivalent of running ",a.createElement(n.code,null,"kubectl")," server-side apply using your design."),"\n"),"\n"),a.createElement(n.h2,null,"üõë The Most Important Part: Reload Behavior"),a.createElement(n.p,null,"This is critical: ",a.createElement(n.strong,null,"Using Kanvas Designer to update a ConfigMap does NOT change how your application reloads it.")),a.createElement(n.p,null,"Deploying from Kanvas is just a friendly, visual way to run ",a.createElement(n.code,null,"kubectl apply"),". The rules we discussed in our previous post about ConfigMap behavior still apply completely:"),a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"If your Pod consumes the ConfigMap as Environment Variables:")," Your running Pods ",a.createElement(n.strong,null,"will not")," see the change. You must still restart them (e.g., ",a.createElement(n.code,null,"kubectl rollout restart deployment ..."),")."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"If your Pod consumes the ConfigMap as a Mounted Volume:")," The files inside the Pod ",a.createElement(n.strong,null,"will")," be updated (after the kubelet sync delay), but your application ",a.createElement(n.em,null,"still")," needs to be smart enough to re-read that file from disk."),"\n"),a.createElement(n.p,null,"Kanvas Designer simplifies the ",a.createElement(n.em,null,"applying")," of the change and helps you visually manage your application's state, but it doesn't change the fundamental Kubernetes behavior of ",a.createElement(n.em,null,"how")," that change is consumed by your workloads."))}var i=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.R)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},s=t(60522),u=t(60145),c=t(63562);const m=e=>{let{data:n,children:t}=e;return a.createElement(a.Fragment,null,a.createElement(c.Ay,null,a.createElement(u.A,{data:n},t)))};function d(e){return a.createElement(m,e,a.createElement(i,e))}const p=e=>{var n,t,l,o;let{data:r}=e;const{frontmatter:i}=r.mdx,u=(null===(n=i.thumbnail)||void 0===n?void 0:n.publicURL)||(null===(t=i.thumbnail_svg)||void 0===t?void 0:t.publicURL)||(null===(l=i.darkthumbnail)||void 0===l?void 0:l.publicURL)||(null===(o=i.darkthumbnail_svg)||void 0===o?void 0:o.publicURL);return a.createElement(s.A,{title:i.title,image:u,description:i.description})}}}]);