{
    "componentChunkName": "component---src-templates-resource-single-js",
    "path": "/resources/service-mesh/value-of-a-service-mesh",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Value of a Service Mesh\",\n  \"thumbnail\": \"./service-mesh.svg\",\n  \"category\": \"Service Mesh\",\n  \"type\": \"Article\",\n  \"tags\": [\"Service mesh\"],\n  \"featured\": false,\n  \"published\": true,\n  \"resource\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(ResourcesWrapper, {\n    mdxType: \"ResourcesWrapper\"\n  }, mdx(\"div\", {\n    className: \"intro\"\n  }, mdx(\"p\", null, \"Learn more about service mesh fundamentals in \", mdx(Link, {\n    className: \"blog\",\n    to: \"/learn/service-mesh-books/the-enterprise-path-to-service-mesh-architectures-2nd-edition\",\n    mdxType: \"Link\"\n  }, \"The Enterprise Path to Service Mesh Archictures (2nd Edition)\"), \" -  free book and excellent resource which addresses how to evaluate your organization\\u2019s readiness, provides factors to consider when building new applications and converting existing applications to best take advantage of a service mesh, and offers insight on deployment architectures used to get you there.\")), mdx(\"p\", null, \"Service meshes provide visibility, resiliency, traffic, and security control of distributed application services.\"), mdx(\"h3\", null, \"Observability\"), mdx(\"p\", null, \"Many organisations are attracted to the uniform observability that service meshes provide. There is no such thing as a fully healthy complex system. Service-level\\xA0 t elemetry\\xA0sheds light on difficult-to-answer questions like why your requests are slow\\xA0to respond. It's quite simple to figure out when a service is down, but figuring out where it's slow and why is a different story.\"), mdx(\"p\", null, \"Service meshes allow both black-box (observing a system from the outside) and white-box (monitoring a system from the inside)\\xA0monitoring of service-to-service communication. To provide white-box monitoring, some service meshes combine with a distributed tracing library. In contrast, other service meshes\\xA0use protocol-specific filters as a capability of their proxies to provide a deeper level of visibility. The components of the data plane are well-positioned (transparently, in-band) to create metrics, logs, and traces, ensuring uniform and thorough observability across the mesh.\"), mdx(\"div\", {\n    className: \"center\"\n  }, mdx(\"img\", {\n    src: Mixer,\n    align: \"right\",\n    alt: \"Istio Mixer\"\n  }), mdx(\"p\", null, \"Figure 1: Istio\\u2019s Mixer is capable of collecting multiple telemetric signals and sending those signals to backend monitoring, authentication, and quota systems via adapters\")), mdx(\"p\", null, \"Service meshes centralize and assist in solving these observability challenges by providing the following:\"), mdx(\"div\", {\n    className: \"right\"\n  }, mdx(\"img\", {\n    src: Metrics,\n    align: \"right\",\n    alt: \"Request Metrics\"\n  }), mdx(\"p\", null, \"Figure 2: Request metrics generated by Istio and visible in Meshery\")), mdx(\"ul\", null, mdx(\"li\", null, mdx(\"strong\", null, \"Logging\"), mdx(\"p\", null, \"Logs are used to baseline visibility for access requests to your entire fleet of services. Figure 1 illustrates how telemetry transmitted through service mesh logs include source and destination, request protocol, endpoint (URL), response time, size, and associated response code.\")), mdx(\"li\", null, mdx(\"strong\", null, \"Metrics\"), mdx(\"p\", null, \"Metrics are used to eliminate the need for the development process to instrument code in order to emit metrics. When metrics are ubiquitous\\xA0across your cluster, additional insights become available. Consistent metrics allow for things like autoscaling to be automated. Telemetry emitted by service mesh metrics include global request volume, global success rate, individual service responses by version, source and time.\")), mdx(\"li\", null, mdx(\"strong\", null, \"Tracing\"), mdx(\"p\", null, \"Slow services (as opposed to services that simply fail) are the most difficult to debug without tracing. Imagine manually enumerating and tracking all of your service dependencies in a spreadsheet. Dependencies, request volumes, and failure rates are visualised using traces. Service meshes enable incorporating tracing functionality extremely simple with the help of\\xA0automatically generated span identifiers. The mesh's individual services still must forward context headers.\\xA0 Many application performance management (APM) solutions, on the other hand, need manual instrumentation to extract traces from your services.\"))), mdx(\"h3\", null, \"Traffic control\"), mdx(\"p\", null, \"Service meshes provide for granular, declarative control over network traffic, such as determining where a request should be routed to perform\\xA0canary release. Circuit breaking, latency-aware load balancing, eventually consistent service discovery, timeouts, deadlines, and retries are all common resiliency features.\"), mdx(\"p\", null, \"When a request does not return to the client within a certain amount of predefined\\xA0time, a  \", mdx(\"strong\", null, \"timeout\"), \" is used to terminate it. They provide a time restriction on how much time can be spent on an individual\\xA0request and are enforced at a point after which a response is considered invalid. \", mdx(\"strong\", null, \"Deadlines\"), \" are an advanced service mesh feature that helps minimise retry storms by facilitating feature-level timeouts rather than independent service timeouts. As a request travels through the mesh, deadlines deduct time remaining to handle it at each stage, propagating elapsed time with each downstream service call.\\xA0 Timeouts and deadlines\\xA0might be considered enforcers of your Service-Level Objectives (SLOs).\"), mdx(\"p\", null, \"You can choose to retry a request if a service\\xA0times out or is unsuccessfully returned. Retrying the same call to a service that is already under water (retry three times = 300 percent additional service load) can make things worse. Retry budgets (aka\\xA0maximum retries) offer the benefit of multiple tries but come with a limit to avoid overloading an already a load-challenged\\xA0service. Some service meshes go even further to reduce client contention by using jitter and an exponential back-off algorithm to calculate the timing of the\\xA0next retry attempt.\"), mdx(\"div\", {\n    className: \"left\"\n  }, mdx(\"img\", {\n    src: Timeouts,\n    align: \"right\",\n    alt: \"Deadlines\"\n  }), mdx(\"p\", null, \"Figure 3:Deadlines, not ubiquitously supported by different service meshes, set feature-level timeouts\")), mdx(\"p\", null, \"You can choose to fail fast and disconnect the service, prohibiting calls to it, rather than retrying and putting more load to the service. \", mdx(\"strong\", null, \"Circuit breaking\"), \" allows users to set\\xA0configurable\\xA0timeouts (or failure thresholds) to assure safe maximums and graceful failure, which is common for slow-responding services. When applications (services) are oversubscribed, using a service mesh as a distinct layer to implement circuit breaking minimises undue overhead.\"), mdx(\"p\", null, mdx(\"strong\", null, \"Rate limiting\"), \"(throttling) is implemented to\\xA0ensure service stability. When requests by\\xA0one client\\xA0surge, the service continues to function smoothly for others. The rate limits are calculated over a period of time. You can also utilise various algorithms, such as a fixed or sliding window, a sliding log, etc. The purpose of rate limits is to ensure that your services are not oversubscribed.\"), mdx(\"p\", null, \"When a limit is reached, well-implemented services commonly adhere to IETF RFC 6585, sending 429 Too Many Requests as the response code, including headers, such as the following, describing the request limit, number of requests remaining, and amount of time remaining until the request counter is reset:\"), mdx(\"div\", {\n    className: \"fact-left\"\n  }, mdx(\"p\", null, \"X-RateLimit-Limit: 60\"), mdx(\"p\", null, \"X-RateLimit-Remaining: 0\"), mdx(\"p\", null, \"X-RateLimit-Reset: 1372016266\")), mdx(\"p\", null, mdx(\"strong\", null, \"Quota management\"), \" (or conditional rate-limiting) accounts for requests based on business requirements instead of limiting rates based on operational concerns. It can be difficult to tell the difference between rate limiting and quota management because both features are handled by the same service mesh capability but are exposed to users in different ways.\"), mdx(\"p\", null, \"Configuring a policy setting a threshold for the number of client requests allowed to a service over time is the canonical example of quota management. User Lee, for example, is on the Free service plan and is allowed upto\\xA010 requests per day. Quota policy imposes consumption limitations on services by keeping track of incoming requests in a distributed counter,often using\\xA0an in-memory datastore like Redis\\xA0 Conditional rate limits are a powerful service mesh capability when applied based on a user-defined set of arbitrary attributes.\"), mdx(\"h3\", null, \"Security\"), mdx(\"div\", {\n    className: \"right\"\n  }, mdx(\"img\", {\n    src: Communication,\n    align: \"right\",\n    alt: \"Communication Paths\"\n  }), mdx(\"p\", null, \"Figure 4: An example of service mesh architecture. Secure communication paths in Istio\")), mdx(\"p\", null, \"For securing service-to-service communication, most service meshes include a certificate authority that manages keys and certificates. Certificates are generated for each service and serve as the service's unique identifier. When sidecar proxies are employed, they assume the identity of the service and perform lifecycle management\\xA0of certificates (creation, distribution, refresh, and revocation) on its behalf.\\xA0\\xA0 Local TCP connections are often established between the service and the sidecar proxy, whereas mutual Transport Layer Security (mTLS) connections are typically established between proxies in sidecar proxy deployments.\"), mdx(\"p\", null, \"Internal traffic within your application should be encrypted as a matter of security. The service calls in your application are no longer contained within a single monolith via localhost; they are now exposed over the network. Allowing service calls without TLS on the transport is a recipe for disaster in terms of security. When two mesh-enabled services communicate, they have strong cryptographic proof of their peers.\\xA0\\xA0 After identities have been established, they are used to create access control policies that determine whether or not a request should be serviced. Policy controls configuration of the key management system (e.g., certificate refresh interval) and operational access control are used to determine whether a request is accepted, based on service mesh employed. Approved and unapproved connection requests, as well as more granular access control parameters like time of day, are identified using white and blacklists.\"), mdx(\"h3\", null, \"Delay and fault injection\"), mdx(\"p\", null, \"It's important to accept that your networks and/or systems will fail. Why not introduce failure and verify behaviour ahead of time? As proxies sit in line to service\\xA0traffic, they frequently support protocol-specific fault injection, which allows you to configure\\xA0the percentage of requests that should be subjected to faults or network delays. For example, generating HTTP 500 errors might be used to test the robustness of your distributed application's response behaviour.\"), mdx(\"p\", null, \"Injecting latency into requests without a service mesh is a time-consuming procedure, but it is probably a more prevalent problem encountered during\\xA0 operation of an\\xA0application. Users are far more irritated by slow replies that result in an HTTP 503 after a minute of waiting than by a 503 after a few seconds. The finest element of these resilience testing capabilities\\xA0is that no application code needs to be changed to make these tests possible. The results of the tests, on the other hand, may prompt you to make changes to the application code.\"), mdx(\"p\", null, \"Using a service mesh, developers spend far less time creating code to cope with infrastructure issues\\u2014code\\xA0that could be commoditized by service meshes in the future. The separation of service and session-layer concerns from application code is manifested as a phenomenon I refer to as decoupling at Layer 5.\"), mdx(\"p\", null, \"A service mesh can be regarded of as surfacing the OSI model's session layer as a separately addressable, first-class citizen in your modern architecture. They are a secret weapon of cloud native systems, waiting to be exploited as a highly configurable work horse.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Value of a Service Mesh","subtitle":null,"date":null,"author":null,"category":"Service Mesh","tags":["Service mesh"],"thumbnail":{"childImageSharp":null,"extension":"svg","publicURL":"/static/cb310234b6631abcabb632a85974a3dd/service-mesh.svg"}},"fields":{"slug":"/resources/service-mesh/value-of-a-service-mesh"}}},"pageContext":{"slug":"/resources/service-mesh/value-of-a-service-mesh"}},
    "staticQueryHashes": ["112401468","1247637131","1485533831","1556364868","1872757318","2104129793","2376360048","2535621439","2799848284","3127805956","3180254910","3205812809","3331006692","3403127739","3469917121","3532464890","3657813679","3666442589","3831724438","4047814605","426370538","673082005","78753834","7929417","803866341"]}