{"componentChunkName":"component---src-templates-blog-tag-list-js","path":"/blog/tag/projects.html","result":{"data":{"allMdx":{"nodes":[{"id":"de0c7552-7a04-5f35-8a06-4b6842d35504","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\n\n<BlogWrapper>\n\nHola folks,\nAs a contributor, each of us is always striving hard in the ocean to open more and more pull-requests, but being a contributor just doesn't mean only raising PRs, it also means reviewing other PRs, pointing out mistakes, helping others in improving the **code-quality/code-reusability/code-readability**, helping in finding missing edge-cases that haven't been tackled yet, giving your opinions, writing LGTM, CITY helps nothing but just improving the confidence and engagement of the PR author.\nSo put on your **Quality Tester** hats because here I'll talk about how to test the PRs with the label `component/mesheryctl` i.e. pull-requests related to `mesheryctl`.\n\nOkay before we start, I'll like to tell you about <a href=\"https://github.com/cli/cli\">GitHub CLI</a>, it helps you checkout PRs very easily in your local system.\n<ol>\n    <li>The very first step is to **review the PR**, suggest changes if you think of any, ask queries, help the author to improve the code quality/readability/reusability, ask questions because asking helps you learn asking more better questions next time.</li>\n    <li>PR authors either attach a video showcasing expected behavior or add written instructions about their fix under **User Acceptance Behavior**.</li>\n    <li>Now it's the time to **checkout PR** in your local system, we can check out any PR like this:<pre><code className=\"language-bash\">gh pr checkout https://github.com/meshery/meshery/pull/4823</code></pre></li>\n    <li>You can check if you're into the same branch as the PR author with:<pre><code className=\"language-bash\">git branch</code></pre></li>\n    <li>Well, if we're testing a PR related to mesheryctl, we need to **build the binary** from the same branch. Change your directory to the `mesheryctl` folder and run:<pre><code className=\"language-bash\">make</code></pre>This will create a **mesheryctl binary** according to your OS in the same directory.</li>\n    <li>Now it's time to **test out this newly built binary** according to what's been tackled in the PR and related issues. For e.g. `system start` has some new functionality, make sure you followed the pull-request/linked-issue instruction for env setup, as sometimes fix/features are tackling an issue with a specific type of environment.<pre><code className=\"language-bash\">./mesheryctl system start</code></pre>the `./` helps us in using the newly built cli-binary present in the current directory which we built in 5th step.</li>\n</ol>\n<ol start=\"7\">\n    <li>Make sure we have a similar experience as mentioned in the Video or the instructions added to the PR. But wait, is it okay to give green flags to the PR? not yet tbh. We as a tester should **turn a little evil** and think of the relevant situations/environments which might not have been tackled but should be (basically we're trying to **break the new feature/fix**).</li>\n    <li>After spending a good amount of time testing the new behaviors, old standard behaviors, new test cases, few edge cases. We can provide new insights to the PR author about the behavior in your system, depending on our experience we can ask the PR author to address our new queries, or we can appreciate the work, or give green flags to the PR.</li>\n</ol>\nWow, that was a ton of work there. Well being a **Tester** is tough but very important before we merge pull requests. Every PR should be marked green with **end-to-end testing** before merging, we as a project are using **GH Workflows** to perform standard golang-testing but manual end-to-end testing completely removes margins of error.\n</BlogWrapper>","frontmatter":{"title":"Validating Meshery CLI Functionality","subtitle":"An introduction to testing mesheryctl","date":"June 10th, 2022","author":"Piyush Singariya","thumbnail":{"extension":"webp","publicURL":"/static/9156c22b67aedb4c9c71f4951b06f17f/thumbnail.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAADwAgCdASoUAAcAPtFUo0uoJKMhsAgBABoJZwCdADBsAAD+8CVGzfndbE6d1gAA"},"images":{"fallback":{"src":"/static/9156c22b67aedb4c9c71f4951b06f17f/16531/thumbnail.webp","srcSet":"/static/9156c22b67aedb4c9c71f4951b06f17f/a4fab/thumbnail.webp 750w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/16baf/thumbnail.webp 1080w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/5eb4b/thumbnail.webp 1366w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/16531/thumbnail.webp 1895w","sizes":"100vw"},"sources":[]},"width":1,"height":0.36358839050131925}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/9156c22b67aedb4c9c71f4951b06f17f/thumbnail.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAADwAgCdASoUAAcAPtFUo0uoJKMhsAgBABoJZwCdADBsAAD+8CVGzfndbE6d1gAA"},"images":{"fallback":{"src":"/static/9156c22b67aedb4c9c71f4951b06f17f/abe74/thumbnail.webp","srcSet":"/static/9156c22b67aedb4c9c71f4951b06f17f/83606/thumbnail.webp 125w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/ce4a2/thumbnail.webp 250w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/abe74/thumbnail.webp 500w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/1165c/thumbnail.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":182}}}},"fields":{"slug":"/blog/meshery/validating-meshery-cli-functionality"}},{"id":"d3755e16-1694-5614-8d5f-5fe6f590fc95","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport Blockquote from \"../../../../reusecore/Blockquote\";\n\nimport oldDesign from \"./initial-design.webp\";\nimport newDesign from \"./mesheryctl-docs.webp\";\n\n<BlogWrapper>\n\n<div className=\"intro\">\nDocumentation plays a major role in any project. Even if the project is small or too big, the creator or the team behind the project needs to curate the documentation very well such that it'll be useful for new end users to refer and learn to use the project, troubleshoot the problems occurred and lot more. Thus, we, Layer5 have curated the documentation for Meshery to meet such purposes. Not to mention, <code>mesheryctl</code>, the CLI client of Meshery needs a curated documentation as well. This blog describes about the evolution of <code>mesheryctl</code> command reference page.\n</div>\n\n<h3>Initial Command Reference Design</h3>\nThe initial design of <code>mesheryctl</code> command reference page is all made using pure markdown and the functionality is handled using Jekyll, the main framework used for Meshery Docs. This handled great at initial stage but had many limitations, such as:\n    <ul>\n        <li>Updation of YAML for data is often required</li>\n        <li>Design was obselete at initial stage</li>\n        <li>No separate pages for each command and subcommand</li>\n    </ul>\n    Thus, the idea for redesigning the <code>mesheryctl</code> reference page was desperately needed.\n    <a href=\"https://docs.meshery.io\" alt=\"Meshery Documentation\" target=\"_parent\">\n    <img src = {oldDesign} className=\"image-center-shadow\" alt=\"Initial design of mesheryctl command reference\" /></a>\n<h3>Updated Command Reference Design</h3>\nTo tackle the shortcomings of the previous design, I was tasked to redesign the <code>mesheryctl</code> command reference page entirely. This was a big task at first glance to me, as I was a new contributor back then. Eventually after manipulating the reference section with help of great folks, I was able to pull off the task and the design was updated.\n    <a href=\"https://docs.meshery.io\" alt=\"Meshery Documentation\">\n<img src={newDesign} className=\"image-center-shadow\" alt=\"Meshery CLI command reference\" /></a>\n\nThe redesign work was done with help of HTML in markdown and with optimization in YAML code. A sample is given below.\n\n```shell\n    <!-- Copy this template to create individual doc pages for each mesheryctl commands -->\n\n    <!-- Name of the command -->\n    # mesheryctl mesh\n\n    <!-- Description of the command. Preferably a paragraph -->\n    ## Description\n\n    {% assign name = site.data.mesheryctlcommands.cmds[page.command] %}\n    {{ name.description }}\n\n    <!-- Basic usage of the command -->\n    <pre className=\"codeblock-pre\">\n    <div className=\"codeblock\">\n    mesheryctl mesh [flags] \n    </div>\n    </pre>\n    ...........\n```\n\n<h3>Adding auto generation feature in reference</h3>\n\nAs time passed, we realized that the command reference missed something for a while, though the design has been changed. Then, we thought the idea of automating the generation of docs such that developers don't need to change the code in docs section while working towards <code>mesheryctl</code>. That's where we got to know that Cobra library (the library for CLI apps made using golang) has a feature to make doc pages automatically. So we decided to incorporate that feature into <code>mesheryctl</code> docs page as well! After making several changes and a PR, I was finally able to introduce the feature in the docs site!\n\n```\nvar startCmd = &cobra.Command {\n\tUse:   \"start\",\n\tShort: \"Start Meshery\",\n\tLong:  `Start Meshery and each of its service mesh components.`,\n\tArgs:  cobra.NoArgs,\n\tExample: `\n// Start meshery\nmesheryctl system start\n// To create a new context for in-cluster Kubernetes deployments and set the new context as your current-context\nmesheryctl system context create k8s -p kubernetes -s\n// (optional) skip checking for new updates available in Meshery.\nmesheryctl system start --skip-update\n// Reset Meshery's configuration file to default settings.\nmesheryctl system start --reset\n// Silently create Meshery's configuration file with default settings\nmesheryctl system start --yes\n.....\n}\n\t`,\n```\n\nUsing this information provided above in each golang file, the markdown page is generated using Cobra CLI library and thus reducing the workload on the developer by automating via <a href=\"https://github.com/meshery/meshery/blob/master/.github/workflows/mesheryctl-ci.yml#L73\">GitHub Actions</a>.\n<br />\nThis is so far on how the <code>mesheryctl</code> command reference is evolved for now. And I hope that it'll continue to evolve in the field of documentation to serve the users to use Meshery in best way possible.\n</BlogWrapper>\n","frontmatter":{"title":"Evolution of the Meshery CLI Command Reference","subtitle":null,"date":"June 9th, 2022","author":"Aadhitya Amarendiran","thumbnail":{"extension":"webp","publicURL":"/static/8b8429808b6e7381fa812bf1f5d29572/mesheryctl.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRnwAAABXRUJQVlA4IHAAAABwBACdASoUAA0APtFWpEuoJKOhsAgBABoJbACdMoGvtgJwx880HleA8ofTgAD+2VgctvGN2cFdfAJj4YJ0Ha8AiiMSiWh82G/yk9ZshKIR54QST0HBPk98AjqzxGHfuVZiMjvT9XDm39S3tEJ+oAAA"},"images":{"fallback":{"src":"/static/8b8429808b6e7381fa812bf1f5d29572/1c0a1/mesheryctl.webp","srcSet":"/static/8b8429808b6e7381fa812bf1f5d29572/f06bf/mesheryctl.webp 750w,\n/static/8b8429808b6e7381fa812bf1f5d29572/8c7d4/mesheryctl.webp 1080w,\n/static/8b8429808b6e7381fa812bf1f5d29572/1c0a1/mesheryctl.webp 1200w","sizes":"100vw"},"sources":[]},"width":1,"height":0.6316666666666667}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/8b8429808b6e7381fa812bf1f5d29572/mesheryctl.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRnwAAABXRUJQVlA4IHAAAABwBACdASoUAA0APtFWpEuoJKOhsAgBABoJbACdMoGvtgJwx880HleA8ofTgAD+2VgctvGN2cFdfAJj4YJ0Ha8AiiMSiWh82G/yk9ZshKIR54QST0HBPk98AjqzxGHfuVZiMjvT9XDm39S3tEJ+oAAA"},"images":{"fallback":{"src":"/static/8b8429808b6e7381fa812bf1f5d29572/704ce/mesheryctl.webp","srcSet":"/static/8b8429808b6e7381fa812bf1f5d29572/5a879/mesheryctl.webp 125w,\n/static/8b8429808b6e7381fa812bf1f5d29572/6d26b/mesheryctl.webp 250w,\n/static/8b8429808b6e7381fa812bf1f5d29572/704ce/mesheryctl.webp 500w,\n/static/8b8429808b6e7381fa812bf1f5d29572/5c637/mesheryctl.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":316}}}},"fields":{"slug":"/blog/meshery/evolution-of-the-meshery-cli-command-reference"}},{"id":"5d6e85c1-a958-51c5-a20e-1308e5fd0237","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport Blockquote from \"../../../../reusecore/Blockquote\";\n\nimport UnitTest from \"./unit-test.webp\";\nimport IntegrationTest from \"./integration-test.webp\";\nimport TreeGraph from \"./tree-graph.webp\";\n\n<BlogWrapper>\n\n<div className=\"intro \">\nDelivering a high quality user experience is our pinnacle goal in the design of Meshery's CLI: <code>mesheryctl</code>. Delivering a high quality user experience means testing both qualitatively and quantatively. As a concept, quality - whether you're talking about software or anything else - can be directly measured by consistency. A quality user experience is consistent and consistency of <code>mesheryctl</code> is reinforced by its many unit tests.\n</div>\n\n<code>mesheryctl</code> is written in Golang. In the Meshery project, we use CodeCov to calculate the code coverage across <code>mesheryctl</code>'s line of code. And there are plenty of lines of code. Achieving high percentages of code coverage in Meshery's CLI with grows in criticality as we bring more features into <code>mesheryctl</code> as a robust and sophisticated command line client of Meshery. Unit and integration tests bolster and roll up into broader end-to-end, functional testing performed across Meshery and the rest of its components.\nHigh levels of code coverage makes it easier for each project contributor to be confident that their code changes aren’t breaking any preexisting <code>mesheryctl</code> commands, side-swiping their functionality unknowingly, and consequently, unwittingly lowering the quality of Meshery's overall user experience.\n<h3> mesheryctl lines of code</h3>\n\n\n```yaml\n\n    270 text files.\n    106 unique files.\n    166 files ignored.\n\n    cloc v 1.92  T=0.15 s (692.3 files/s, 110063.3 lines/s)\n    ------------------------------------------------------------------\n    Language       files          blank        comment           code\n    ------------------------------------------------------------------\n    Go                88           2128           1330          13045\n    YAML              12              0              0            215\n    JSON               4              0              0             42\n    make               1             10              2             31\n    Markdown           1             23              0             27\n    ------------------------------------------------------------------\n    SUM:             106           2161           1332          13360\n    ------------------------------------------------------------------\n```\n\nUnit Tests can be written in two ways:\n<ol>\n    <li>\n        Test <code>mesheryctl</code> subcommand\n        <ol>\n            <li>Mock Meshery(backend) response if needed</li>\n            <li>Grab console output</li>\n            <li>Store standard/verified mesheryctl output in a golden file(a text file)</li>\n            <li>Match the stored/expected output with what we grab from the console</li>\n            <li>Cover as many scenarios as possible, test the situations where errors must be thrown</li>\n            <li>This is a standard format, changes can be made accordingly</li>\n        </ol>\n    </li>\n    <li>\n        Test <code>mesheryctl</code> functions\n        <ol>\n            <li>This is the standard testing you may have come across in every project</li>\n            <li>You write one test dedicated to one function covering all possible test-cases, matching expected outputs</li>\n        </ol>\n    </li>\n</ol>\n\n<h3>Example tree graph</h3>\nThis example of a tree graph (from <a href=\"https://github.com/meshery/meshery/pull/4823\">meshery/meshery/pull/4823</a>) shows the impact given changes make on the level of code coverage.\n<img src={TreeGraph} />\n\n<h3>Integration Tests</h3>\n\nIntegrations tests come into view when you cannot mock something easily and when a given behavior is cross-functional / cross-component. Integration tests put more, but not all of the focus validating system behavior and that the system completes all the necessary actions. Take <code>mesheryctl system start</code> for example. This command deploys Meshery, its adapters, and Kubernetes Operator; it starts Meshery. So, you run the command to start Meshery in a GitHub workflow and after running the <code>mesheryctl</code> subcommand through the tests and make sure that Meshery actually started. And if the workflow successfully runs the test, then boom!, you aced your integration writing test... errr... test writing.\nThe integration test writing exam can initially be challenging, but... that’s the fun in it. :) Running tests and making sure a command that is otherwise hard to verify, hard to test, and making it automatic through GH workflows.\n<h3>How you can make an impact</h3>\n\nWriting tests and making them work is in itself a tough task to do, so writing one test for a single function counts and makes a big difference over the long term. Don't hesitate. Start writing tests now. A single, new test is worthy of raising a pull request and will get you well on your way to learning much more about Golang, Docker, Kubernetes, and Clouds.\n<ul>\n    <li><a href=\"https://codecov.io/gh/meshery/meshery/\">Codecov</a> is used to check code coverage in <code>mesheryctl</code> (login with GitHub to get an in-depth idea of lines-of-code being covered in code coverage).</li>\n    <li>You can check the files on CodeCov’s website to figure out which mesheryctl commands haven’t been covered by existing tests.</li>\n    <li>Guide: <a href=\"https://docs.google.com/document/d/1xRlFpElRmybJ3WacgPKXgCSiQ2poJl3iCCV1dAalf0k/edit#heading=h.rzpmb66db1sq\">Writing tests for mesheryctl</a>. This guide will briefly introduce how tests are supposed to be written for mesheryctl.</li>\n    <li>Contributing to Tests doesn’t always mean writing new tests, It also means improving the effectiveness of already written-ones.</li>\n    <li> Search for Issues marked with area/tests in <a href=\"https://github.com/meshery/meshery\">GitHub - meshery/meshery</a>: Meshery, the cloud native management plane.</li>\n</ul>\n\nThe impact that you make with by writing even a single test is quite high. Your tests will be executed and used time-and-time again. I can’t explain in words (I don’t have that good of a vocabulary). Your Tests are going to run in each pull request raised against the Meshery project, in each commit someone pushes to a pull request, in every nightly regression test suite, in every release. Just think: if another contributor incidently introduces a defect or doesn't consider for an edge case, and fails to uphold the intended behavior of the code, your tests are going to catch them redhanded. How cool is that?\nSo, what are you waiting for? Jump in and write a few tests today! When you raise your pull request, label it with <code>area/tests</code> and <code>component/mesheryctl</code> and I'll be there to review! Let’s get <code>mesheryctl</code> 100% code coverage badge.\n</BlogWrapper>","frontmatter":{"title":"How to write unit and integration tests for mesheryctl","subtitle":null,"date":"January 6th, 2022","author":"Piyush Singariya","thumbnail":{"extension":"webp","publicURL":"/static/228cadb307e48d8dd59978517c9862a3/integration-test.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAADwAgCdASoUAAcAPtFUo0uwJKMhsAgCABoJaQDImC0kAAD+8jqXyPcoCEgyAAAA"},"images":{"fallback":{"src":"/static/228cadb307e48d8dd59978517c9862a3/45e9e/integration-test.webp","srcSet":"/static/228cadb307e48d8dd59978517c9862a3/0622a/integration-test.webp 750w,\n/static/228cadb307e48d8dd59978517c9862a3/56413/integration-test.webp 1080w,\n/static/228cadb307e48d8dd59978517c9862a3/28a59/integration-test.webp 1366w,\n/static/228cadb307e48d8dd59978517c9862a3/45e9e/integration-test.webp 1882w","sizes":"100vw"},"sources":[]},"width":1,"height":0.35281615302869285}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/228cadb307e48d8dd59978517c9862a3/integration-test.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAADwAgCdASoUAAcAPtFUo0uwJKMhsAgCABoJaQDImC0kAAD+8jqXyPcoCEgyAAAA"},"images":{"fallback":{"src":"/static/228cadb307e48d8dd59978517c9862a3/f82b7/integration-test.webp","srcSet":"/static/228cadb307e48d8dd59978517c9862a3/3b9b0/integration-test.webp 125w,\n/static/228cadb307e48d8dd59978517c9862a3/6c123/integration-test.webp 250w,\n/static/228cadb307e48d8dd59978517c9862a3/f82b7/integration-test.webp 500w,\n/static/228cadb307e48d8dd59978517c9862a3/e30b3/integration-test.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":176}}}},"fields":{"slug":"/blog/meshery/how-to-write-unit-and-integration-tests-for-mesheryctl"}},{"id":"9e6d6d38-989d-5fb6-8743-b7b4ccc5b9b0","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport Blockquote from \"../../../../reusecore/Blockquote\";\n\nimport MeshManager from \"./mesh-manager.webp\";\nimport MesheryClients from \"./meshery-clients.webp\";\nimport Mesheryfeatures from \"./meshery-features.webp\";\nimport MesheryDeployments from \"./meshery-deployment.webp\";\nimport Nighthawk from \"./nighthawk.webp\";\nimport Patterns from \"./patterns.webp\";\nimport ServiceMeshPatterns from \"./service-mesh-patterns.webp\";\nimport Planes from \"./planes.webp\";\nimport Mesheryoperatoricon from \"../../../../assets/images/meshery-operator/meshery-operator.svg\";\nimport MesheryLogo from \"../../../../assets/images/meshery/icon-only/meshery-logo-light.svg\";\nimport NighthawkIcon from \"../../../../assets/images/nighthawk/icon-only/SVG/nighthawk-logo.svg\";\nimport PatternsLogo from \"./patterns-logo.webp\";\nimport { Link } from \"gatsby\";\n\n<BlogWrapper>\n\n<div className=\"intro \">\n\n      Meshery is the open-source, collaborative cloud native manager that can\n    configure 230+ Kubernetes infrastructure, onboard your applications, manage WebAssembly filters, apply cloud native patterns, validate against best practices, and benchmarks the performance of your cloud native deployments. Let’s learn how to manage cloud native infrastructure with confidence with Meshery.{\" \"}\n\n</div>\n\n<h3>Network Planes</h3>\n<img src={Planes} className=\"slides-right\" align=\"right\" alt=\"network-planes\"/>\n  As we unfold what a management plane is, it would serve us well to talk about\n  network planes in this regard. Architecturally, a service mesh consists of two\n  planes. One of those is the data plane, while the other one is the control\n  plane. A service mesh data plane is the collection of intelligent proxies that\n  operate in unison under the coordination of the control plane. The control\n  plane performs configuration management of these intelligent proxies.\n  A management plane can do many things. Essentially, a management plane helps\n  you integrate cloud native infrastructure into your backend systems. A robust management\n  plane allows you to take full advantage of the power of the network while\n  integrating your service delivery processes seamlessly. Your management plane\n  might federate different types of infrastructure, help you instigate chaos\n  through controlled experiments, or offer automated traffic splitting in order\n  to execute different styles of canarying of your applications. Your management\n  plane might offer deep insights into the performance of your applications and\n  to the performance of your infrastructure or might deliver a change in\n  management framework.\n<h3>\n  <img\n    src={MesheryLogo}\n    align=\"center\"\n    alt=\"meshery-logo\"\n    height=\"35rem\"\n    width=\"35rem\"\n    style={{paddingBottom:\"5px\", paddingTop:\"auto\"}}/>{\" \"}\n  Meshery\n</h3>\n\n<img\n  src={MeshManager}\n  className=\"slides-left\"\n  align=\"right\"\n  alt=\"mesh-manager\"/>\n  <Link to=\"/cloud-native-management/meshery\">Meshery</Link> manages the\n  lifecycle of infrastructure. Meshery does workload management, helps you\n  onboard or offboard your applications onto the mesh. It also lets you do\n  performance management.{\" \"}\n  <a href=\"https://docs.meshery.io/concepts/architecture/meshsync\">MeshSync</a>,\n  a custom controller within{\" \"}\n  <Link to=\"/cloud-native-management/meshery/meshery-operator\">Meshery operator</Link>\n  , performs discovery of existing infrastructure and deep fingerprinting of the\n  specific functions that version of your infrastructure is capable of performing.\n  Through MeshSync, Meshery supports brownfield deployments of your infrastructure\n  (Meshery discovers your existing infrastructure deployment that is already running\n  inside your cluster(s) whether those infrastructures were deployed by Meshery or\n  not){\" \"}\n  In order to facilitate such a deep level of understanding of each type of\n  infrastructure, <Link to=\"/cloud-native-management/meshery\">Meshery</Link> has\n  models that are specific to each infrastructure (given that each infrastructure\n  has its own set of features). Consequently, in order to leverage the maximum\n  functionality of each infrastructure, Meshery has separate, dedicated adapter\n  for each of the{\" \"}\n<a href=\"https://docs.meshery.io/getting-started/overview\"> supported models. </a>\n  :{\" \"}\n<table className=\"table-1\" align=\"center\">\n  <thead>\n    <tr>\n      <th align=\"left\">Infrastructure</th>\n      <th className=\"status\">Status</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/consul\"> Meshery Adapter for Consul </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/istio\"> Meshery Adapter for Istio </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/kuma\"> Meshery Adapter for Kuma </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/linkerd\"> Meshery Adapter for Linkerd </a>{\" \"}\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/nsm\"> Meshery Adapter for Network Service Mesh </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/osm\"> Meshery Adapter for Open Service Mesh </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/traefik-mesh\"> Meshery Adapter for Traefik Mesh </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/cpx\"> Meshery Adapter for Citrix Service Mesh </a>\n      </td>\n      <td className=\"status\">beta</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/nginx-sm\"> Meshery Adapter for NGINX Service Mesh </a>\n      </td>\n      <td className=\"status\">beta</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/app-mesh\"> Meshery Adapter for App Mesh </a>\n      </td>\n      <td className=\"status\">alpha</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/tanzu-sm\"> Meshery Adapter for Tanzu Service Mesh </a>\n      </td>\n      <td className=\"status\">alpha</td>\n    </tr>\n  </tbody>\n</table>\n\n  <Link to=\"/cloud-native-management/meshery\">Meshery</Link> also lets you\n  integrate your Prometheus and Grafana add-ons so you can import your existing\n  Grafana dashboards to Meshery. When you first start Meshery, we also have a\n  configuration wizard, which basically walks you through the entire setup to\n  get Meshery up and running. By the end of this, it will make sure that you\n  have Meshery running on your cluster.\n<img\n  src={MesheryDeployments}\n  className=\"slides-right\"\n  align=\"right\"\n  alt=\"meshery-deployment\"/>\n  If you want a more finer configuration, you can configure your environment\n  through settings and you can configure infrastructure, and you can configure\n  the metrics, you can define your performance tests to be reused.\n  For configuration management,{\" \"}\n  <Link to=\"/cloud-native-management/meshery\">Meshery</Link> will analyze your\n  runtime environment for certain infrastructure and tell you if you're doing\n  things right or not. What you can do is you can upload your applications\n  directly into Meshery, edit them in the Meshery UI itself and actually apply\n  these applications or onboard these applications on your infrastructure.\n<h3>\n  <img\n    src={Mesheryoperatoricon}\n    align=\"center\"\n    alt=\"meshery-operator-logo\"\n    height=\"32rem\"\n    width=\"32rem\"\n    style={{paddingBottom:\"5px\", paddingTop:\"auto\"}}/>{\" \"}\n  Meshery Operator\n</h3>\n<img\n  src={Mesheryfeatures}\n  className=\"slides-left\"\n  align=\"right\"\n  alt=\"Meshery-features\"/>\n\n  <Link to=\"/cloud-native-management/meshery/meshery-operator\">Meshery operator</Link>{\" \"}\n  is a custom controller called MeshSync. MeshSync helps keep Meshery apprised\n  of the various changes that are going on to the infrastructure and various\n  changes that are happening within Kubernetes itself. In this way Meshery\n  supports not only greenfield deployments like deploying infrastructure itself,\n  it also supports connecting to existing infrastructure deployments, that is,\n  brownfield deployment. So it will discover your existing deployments as well.\n  There's an extensible concept in Meshery called a{\" \"}\n  <a href=\"https://docs.meshery.io/extensibility/providers\">provider</a>.\n  Providers can typically offer a layer of persistence so to the extent that\n  users are running performance tests intensely or to the extent that users want\n  to have a particular type of directory integrated to bring their own identity\n  to Meshery and have a multi-user experience. The other area of extensibility\n  is the notion that Meshery has a couple of APIs both – rest API and graphql\n  API. It comes with a command-line interface as well as a user interface.{\" \"}\n<h3>Layer5 MeshMap</h3>\n  Another capability of Meshery that is going to be released in the upcoming\n  version is visually configuring your infrastructure using MeshMap. You can add\n  filters, applications as well as make other configurations visually here and\n  you can export it as patterns to make it reusable quite easily. It\n  automatically figures out the sample application we have deployed, then\n  generates a visual representation. It provides users the ability to design\n  infrastructure, infrastructure configuration, and the applications that run on\n  it.\n<img src={Patterns} className=\"slides-left\" align=\"right\" alt=\"Patterns\"/>\n<h3>\n  <img\n    src={PatternsLogo}\n    align=\"center\"\n    alt=\"patterns-logo\"\n    height=\"35rem\"\n    width=\"32rem\"\n    style={{paddingBottom:\"5px\", paddingTop:\"auto\"}}/>{\" \"}\n  Patterns\n</h3>\n  {\" \"}\n  A pattern is capable of describing the deployment of any of the meshes that Meshery\n  supports as well as the configuration of the mesh. It also notes ongoing behavior\n  so if you wanted to run a canary you can describe that in a pattern. So, patterns\n  are like a template, they're customizable and ingestible into Meshery itself.\n<img\n  src={ServiceMeshPatterns}\n  className=\"slides-right\"\n  align=\"right\"\n  alt=\"Service-Mesh-Patterns\"/>\n  Meshery will take action based on what you've described in the pattern, things\n  like generating or running a performance test, generating load, and then doing\n  statistical analysis on that set of results. In the future, if you want to\n  deploy a web assembly filter, you can describe that in a pattern as well and\n  have Meshery apply it. The patterns are infrastructure agnostic, they're\n  reusable and the initial set of them is being stored in a public-facing\n  repository. There are almost 60 patterns that have been identified.\n  Ultimately, it will allow you to ingest these and measure then orchestrate and\n  apply them to your infrastructure. You can also use Meshery to visually\n  represent them and to visually design.\n<h3>\n  <img\n    src={NighthawkIcon}\n    align=\"center\"\n    alt=\"nighthawk-logo\"\n    height=\"35rem\"\n    width=\"35rem\"\n    style={{paddingBottom:\"5px\", paddingTop:\"auto\"}}/>{\" \"}\n  Nighthawk\n</h3>\n  There’s a project called <Link to=\"/projects/nighthawk\">Nighthawk</Link> that\n  helps advance the existing integration of nighthawk and Meshery. Nighthawk is\n  a load generator that is an envoy project. It's written in c plus plus and has\n  a couple of intriguing capabilities that are the ongoing study within\n  Nighthawk. There is an ongoing effort to take advantage of nighthawk’s\n  adaptive load controllers, add a couple of those in and expose them through\n  Meshery to let people recursively evaluate what is ultimately an optimal\n  configuration in your environment and the infrastructure.\n<img src={Nighthawk} className=\"slides-right\" align=\"right\" alt=\"Nighthawk\"/>\n\n  If you consider that you've got a certain SLO or a certain minimum latency\n  requirement that you need to stick to that but you also want to at the same\n  time maximize resiliency characteristics of your deployment, that can be a\n  difficult thing to figure out particularly if any of your infrastructure\n  changes:\n<ul>\n  <li>if you add another node to your environment, your clusters,</li>\n  <li>if you upgrade your infrastructure,</li>\n  <li>if you change the configuration of your infrastructure,</li>\n  <li>\n    if you add another service to your set of workloads that you're running.\n  </li>\n</ul>\n  If these factors change, so does the ability to run optimization routines. To\n  help you identify the optimal configuration of your infrastructure but in accordance\n  with your own constraints is again the study of{\" \"}\n  <Link to=\"/projects/nighthawk\">Nighthawk</Link>.{\" \"}\n<h3>\n  Check out the CNCF On-Demand Webinar:{\" \"}\n  <Link to=\"/cloud-native-management/meshery\">Meshery</Link> - The Cloud Native\n  Manager to learn more!\n</h3>\n<div className=\"iframe-container\">\n\n  <iframe\n    width=\"460\"\n    height=\"215\"\n    src=\"https://www.youtube.com/embed/mU8qHUGYsk8\"\n    loading=\"lazy\"\n    title=\"YouTube video player\"\n    frameborder=\"0\"\n    allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n    allowfullscreen\n  ></iframe>\n\n</div>\n\n</BlogWrapper>","frontmatter":{"title":"An Introduction to Meshery (Webinar-on-Demand) ","subtitle":null,"date":"October 9th, 2021","author":"Debopriya Bhattacharjee","thumbnail":{"extension":"webp","publicURL":"/static/28ae2a6f951a849aa29443d8f5f79f4e/meshery-webinar.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRmwAAABXRUJQVlA4IGAAAABQAwCdASoUAAsAPtFipk0oJiOiMAgBABoJZgCw7GlXTbijAAD+0jMMBfop23C2fGXyMOcvtj4R0cAWOYI9rXbL4gq6+9RFfodXXX946n/c7bfC7T9i6EDDw4DwHhsAAAA="},"images":{"fallback":{"src":"/static/28ae2a6f951a849aa29443d8f5f79f4e/847c8/meshery-webinar.webp","srcSet":"/static/28ae2a6f951a849aa29443d8f5f79f4e/06597/meshery-webinar.webp 750w,\n/static/28ae2a6f951a849aa29443d8f5f79f4e/847c8/meshery-webinar.webp 810w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5641975308641975}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/28ae2a6f951a849aa29443d8f5f79f4e/meshery-webinar.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRmwAAABXRUJQVlA4IGAAAABQAwCdASoUAAsAPtFipk0oJiOiMAgBABoJZgCw7GlXTbijAAD+0jMMBfop23C2fGXyMOcvtj4R0cAWOYI9rXbL4gq6+9RFfodXXX946n/c7bfC7T9i6EDDw4DwHhsAAAA="},"images":{"fallback":{"src":"/static/28ae2a6f951a849aa29443d8f5f79f4e/6e8bd/meshery-webinar.webp","srcSet":"/static/28ae2a6f951a849aa29443d8f5f79f4e/9299f/meshery-webinar.webp 125w,\n/static/28ae2a6f951a849aa29443d8f5f79f4e/81c3e/meshery-webinar.webp 250w,\n/static/28ae2a6f951a849aa29443d8f5f79f4e/6e8bd/meshery-webinar.webp 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":282}}}},"fields":{"slug":"/blog/meshery/an-introduction-to-meshery-webinar-on-demand"}},{"id":"c0ba14fc-089b-5939-abc8-083252a26606","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport Blockquote from \"../../../../reusecore/Blockquote\";\n\nimport Hamlet from \"./Hamlet.webp\";\nimport Graph from \"./Graph1.webp\";\nimport Bucket from \"./Graph2.webp\";\nimport SMI from \"./SMI-demo.webp\";\nimport SMP from \"./SMP.webp\";\nimport Abstractions from \"./abstractions.webp\";\nimport Journey from \"./cloud-native-journey.webp\";\nimport Flowchart from \"./flowchart.webp\";\nimport { Link } from \"gatsby\";\n\n\n<BlogWrapper>\n\n<div className=\"intro \">\n\n     <Link to=\"/community/members/lee-calcote\">Lee Calcote</Link> is an innovator, product and technology leader, active in the community as a Docker Captain, Cloud Native Ambassador and GSoC, GSoD, and Community Bridge Mentor. In this talk, he walked through service mesh specifications and why they matter in your deployment.\n   How many service mesh specifications do you know? He went through all of them. So, no worries if you're unfamiliar.\n\n</div>   \n\n### Service Mesh Specifications:\n<img src={Abstractions} className=\"slides-left\" align=\"left\" alt=\"abstractions\"/>\n\nAs the ubiquity of service meshes unfolds and they become a commonplace for any cloud native or edge environment, so does the need for vendor and technology-agnostic interfaces to interact with them. The Service Mesh Interface (SMI), the Service Mesh Performance (SMP), and Multi-Vendor Service Mesh Interoperation (Hamlet) are three open specifications solving the challenge of interoperability, workload and performance management between service meshes. \n\nLearn what makes each of them unique and why they are much needed. See each of these three specifications in action as we use Meshery, the open-source service mesh management plane to demonstrate the value and functionality of each service mesh abstraction, and the adherence of these specifications by Istio, Linkerd, Consul and other popular service meshes.\n\n### Cloud native Journey to service meshes:\n\n<img src={Journey} className=\"slides-right\" align=\"right\" alt=\"journey-image\"/>\n\nThe advent of cloud native was the popularization of containers. Thank you Docker! From there, containers took off like wildfire. Turns out you need an orchestrator to wrangle that sprawl. We saw a number of orchestrators come and we still have a number of orchestrators around.\n\nService meshes have become a hot topic in the last few years. They still continue to be, rightfully so, a very powerful piece of technology. “A lot of the power is yet to come from my perspective. For my part, I believe that there is a tomorrow in which data plane intelligence really matters. And matters about how people write cloud native applications.”, Lee emphasized. Not everyone quite understands the capabilities of meshes as they are promoted and spoken about today. So come along into the journey of service mesh.\n\nThere are a number of service meshes out there. One of the community projects is to track the landscape of all of the meshes there are. There’s a lot to say about each of them, their architecture, and their working. Why are they made? Who are they focused on? What do they do? When did they come about? Why are some of them not here anymore? Why are we still seeing new ones? A lot of things to go through. You might be interested in any number of the details that the landscape tracks.\n <div className=\"note\">Be Aware, It's Meshy Out There!</div>\n\n### Service Mesh Interface\n<img src={SMI} className=\"slides-left\" align=\"left\" alt=\"smi-image\"/>\n- Its goal and genesis were born inside of Kubernetes.\n- Being a specification that is native to Kubernetes, its focus is on lowest common denominator functionality.\n- The focus on bringing forth APIs that highlight and reinforce the most common use cases that service meshes are being used for currently\n- Leaves space and provides extensibility room for additional APIs to address other service mesh functionality as more people adopt and make use cases well known.\n- There are seven service meshes that claim compatibility with SMI. There's been a community effort, open-source effort to create service mesh conformance tests to assert whether or not a given service mesh is compatible with SMI\n- In order to facilitate those types of tests, you need to have a tool to provision a sample application on those services which will generate load and test whether traffic splitting behaves as expected or works with that service mesh implementation properly.\n- Then you need to be able to collect the results, guarantee the provenance of those results and publish them.\n- As a community, we turned to Meshery as the tool to implement <Link to=\"/projects/service-mesh-interface-conformance\">SMI conformance</Link> and we have been working with the individual service meshes to validate their conformance.\n<b>Meshery</b>\n- We work on an open-source project called <Link to=\"/cloud-native-management/meshery\">Meshery</Link>.\n- Meshery, the cloud native management plane, is the canonical implementation of the service mesh performance.\n- The management planes can do a number of things to help bridge the divide between other back-end systems and service meshes. They also help performance management, configuration management, making sure you are following best practices in your implementations by taking common patterns and applying them to your environment\nLet's take a moment to demo what it looks like to validate conformance in SMI using Meshery.\n\n<img src={Graph} className=\"slides-left\" align=\"left\" alt=\"graph\"/>\n- We need to spin up Meshery locally\n- We use mesheryctl as the command line interface to work with Meshery.\n- We can interact with a number of different service mesh. The service mesh we’re going to work with today is an Open service mesh (one of those 7 that is compatible with SMI). Let’s put it to the test.\n- We'll initiate <Link to=\"/projects/service-mesh-interface-conformance\">SMI conformance</Link>\n- These tests go and do assertions across these different specifications. We’re looking at traffic access, traffic splitting, traffic specification. Meshery then collects these results and will eventually be publishing them in combination with the SMI project.\n\n### Service Mesh Performance\n<img src={SMP} className=\"slides-right\" align=\"right\" alt=\"smp-image\"/>\n- Focused on describing and capturing the performance of a service mesh.\n- The overhead of the value is another way of looking at it and characterizing it.\n- Trying to characterize the performance of the infrastructure of a service mesh can be really difficult.\n- Considering the number of variables that you would have to track, how difficult it can be to have repeatable tests, and benchmark your environment, to track your history based on your environment, compare performance between other meshes people need.\n- SMP creates a standard way of capturing the performance of the mesh to help with these issues.\n- It's also the way in which you're configuring your control plan of your service mesh.\n\nYou might be using a client library to do some service mesh functionality. Maybe you're using those in combination with the service mesh. What costs more? What's more efficient? What's more powerful? Maybe you're using web assembly and filters there.\nThese are all open questions that <Link to=\"/projects/cloud-native-performance\">SMP</Link> assists in answering in your environment. You’d be surprised by some of the results of some tests that we have done and that the community has done in combination with a couple of universities and graduate students.\n\n<b>Performance Test</b>\n\nDemonstration of the implementation of service mesh Performance:\n\n<img src={Flowchart} className=\"slides-left\" align=\"left\" alt=\"flowchart\"/>\n- On the terminal, we have a local deployment of Meshery running. You can also deploy on Kubernetes as well as the vendor Kubernetes platforms like AKS, EKS and GCP or you can use a dockerized container to run Meshery. You can also have your Kubernetes on Docker desktop.\n- We have the Open service mesh deployed.\n- The Meshery UI is exposed at 9081 port. This is the UI which is used to instantiate a Load test.\n- Over here you can see we have 3 load generators fortio, wrk2, nighthawk.\n- All of these load generators have their own set of attributes which they record correctly and each of its attributes have their own significance. We begin with fortio.\n- <img src={Bucket} className=\"slides-right\" align=\"right\" alt=\"graph\"/>\n\n- You can actually download the test results or you can just browse into the Results Tab and see all of the tests which you have run until now.\n- Next, we used nighthawk to generate the load and benchmark the service for the same. Nighthawk is a load generator which is maintained by the Envoy community and is relatively new. It still hasn't got its 1.0 release but right now Nighthawk has sufficient features to compete with different generators which are still in the play. It can generate a gRPC service on its own and it has some more attributes which you can expose using their CLI tools.\n- You can also see that Meshery has the capability to search your environment, see what specifications are being used and what's the load on your Kubernetes.\n- Jump into the results Tab and see how we compare with these results.\n- You can click on the download. You will see that a yaml gets downloaded in which you can browse and see that the start time, load time, the performance latencies, the metrics are being captured.\n\n### Hamlet or Multi-vendor Service Mesh Interoperation\n<img src={Hamlet} className=\"slides-left\" align=\"left\" alt=\"hamlet-image\"/>\n- Focus on service mesh federation\n- Specifies a set of API standards for enabling service mesh federation\n- Hamlet takes on a client-server architecture in which resources and services of one service mesh are discovered, registered and using a common format, information about them is exchanged between different service mesh.\n- Rules around authentication and authorization rules around which Services get exposed and to whom and who can communicate with them and whether or not they can do it securely. These are things that Hamlet addresses.\n- The specification currently consists of two APIs:\n    - **The Federated Resource Discovery API**: API to authenticate and securely distribute resources between federated service meshes.\n    - The **Federated Service Discovery API**: API to discover, reach, authenticate and securely communicate with federated services.\n- Part of the real power is the ability to overcome what are likely to be separate administrative domains. The intention here is to marry up connect two disparate service mesh deployments, those deployments might be of the same type, they might be of two different types.\n\nIn addition to SMI, SMP and Hamlet there has been an emergence of service mesh patterns, by which people are running and operating service meshes. There is a service mesh working group under CNCFs network that is helping identify those patterns of which there's a list right now unbeknownst to you. Reach out, join it, help us work through the 60 patterns that are defined right now. 30 of those are going into an <Link to=\"/learn/service-mesh-books\">O’Reilly</Link> book called <Link to=\"/learn/service-mesh-books/service-mesh-patterns\">Service Mesh Patterns</Link>.\n\nSomething that isn’t always obvious to folks is this piece of value that people get from a service mesh and actually from the specifications that we were just mentioning. It is the fact that teams are decoupled when you’re running a mesh. Developers get to iterate a bit independently of operators, and so do operators get to make changes to implement infrastructure to the way that applications behave independent of developers in the presence of a mesh.  Both of these teams are significantly empowered. Everybody gets a piece of power when they deploy a mesh.\n\n\n_**P.S.: If these topics excite  come and say \"Hi\" on our [Slack Channel](http://slack.layer5.io) and one of us will reach out to you!**_\n\n</BlogWrapper>","frontmatter":{"title":"Service Mesh Specifications and Why They Matter","subtitle":null,"date":"September 20th, 2021","author":"Debopriya Bhattacharjee","thumbnail":{"extension":"webp","publicURL":"/static/f9e70b0d102359852501532eaf88c857/Cover-image.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRnYAAABXRUJQVlA4IGoAAAAQBACdASoUAAsAPtFUo0uoJKMhsAgBABoJbACdMoR3N4AAWScxK3A0AAD+y+7TltDm8faWnWkrgNwKEaB+a5F7h6kfv+PNmIbiHtDLJbrKy70mpaSz/NUvAS+UKSii+WgoY4/+Ld6wAAAA"},"images":{"fallback":{"src":"/static/f9e70b0d102359852501532eaf88c857/92e8b/Cover-image.webp","srcSet":"/static/f9e70b0d102359852501532eaf88c857/a66aa/Cover-image.webp 750w,\n/static/f9e70b0d102359852501532eaf88c857/65dd5/Cover-image.webp 1080w,\n/static/f9e70b0d102359852501532eaf88c857/f9724/Cover-image.webp 1366w,\n/static/f9e70b0d102359852501532eaf88c857/92e8b/Cover-image.webp 1920w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5630208333333334}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/f9e70b0d102359852501532eaf88c857/Cover-image.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRnYAAABXRUJQVlA4IGoAAAAQBACdASoUAAsAPtFUo0uoJKMhsAgBABoJbACdMoR3N4AAWScxK3A0AAD+y+7TltDm8faWnWkrgNwKEaB+a5F7h6kfv+PNmIbiHtDLJbrKy70mpaSz/NUvAS+UKSii+WgoY4/+Ld6wAAAA"},"images":{"fallback":{"src":"/static/f9e70b0d102359852501532eaf88c857/cd07d/Cover-image.webp","srcSet":"/static/f9e70b0d102359852501532eaf88c857/46142/Cover-image.webp 125w,\n/static/f9e70b0d102359852501532eaf88c857/81c3e/Cover-image.webp 250w,\n/static/f9e70b0d102359852501532eaf88c857/cd07d/Cover-image.webp 500w,\n/static/f9e70b0d102359852501532eaf88c857/bf95e/Cover-image.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":281}}}},"fields":{"slug":"/blog/service-mesh/service-mesh-specifications-and-why-they-matter"}},{"id":"f3698102-848c-561d-bb18-e29be1e80e1f","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport { Link } from \"gatsby\";\nimport MesheryOperatorShot from \"./meshery-operator-v0.5.0.webp\";\nimport MesheryOperator from \"./meshery-operator-dark.svg\";\nimport MeshSync from \"./meshsync.svg\";\nimport MesheryDB from \"./meshery-database.svg\";\nimport MesheryAdapterLibrary from \"./meshery-adapter-library.svg\";\nimport Traefik from \"./traefik-mesh.svg\";\nimport MesheryExtensibility from \"./meshery-extensibility.svg\";\nimport NGINXSM from \"./nginx-service-mesh.svg\";\nimport layer5Logo from \"../../../../assets/images/layer5/layer5-only/svg/layer5-no-trim.svg\";\n\n<BlogWrapper>\n\n<strong>We're pleased to announce the release of Meshery 0.5.0!</strong>  \nConsisting of several significant architectural enhancements — with eight new capabilities entering alpha — Meshery v0.5.0 delivers an impressive amount of functionality.\n\nPreviewed in the <i>Using Istio</i> workshop delivered at the  \n<Link to=\"/community/events/istiocon-2021\">inaugural IstioCon 2021</Link>, Meshery v0.5.0 lays a strong foundational architecture for cloud-native application and service mesh management.\n\n## Feature Highlights\n\n- New GraphQL API  \n- Meshery Operator with MeshSync inside  \n- Meshery Adapter for Traefik Mesh (beta)  \n- MeshKit and the Meshery Adapter Library  \n- Meshery Adapter for NGINX Service Mesh (alpha)  \n- Meshery Remote Provider extensions with dynamic injection  \n- New Meshery CLI commands to manage multiple Meshery deployments  \n\n<div\n  className=\"intro\"\n  style={{\n    textAlign: \"center\",\n    display: \"flex\",\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    margin: \"2rem\"\n  }}\n>\n  <img\n    src={layer5Logo}\n    alt=\"Layer5 logo\"\n    style={{ maxHeight: \"55px\", margin: \"auto\", padding: \".5rem\" }}\n  />\n  <p style={{ flexBasis: \"50%\", width: \"100%\", margin: 0 }}>\n    Thank you to the wonderful Layer5 community of open source contributors for\n    making this significant release possible.\n  </p>\n</div>\n\n## New Service Mesh Support\n\n<span className=\"bigfirstletter\">2</span> new Meshery service mesh adapters are bundled in this release:  \nThe Meshery Adapter for Traefik Mesh and the Meshery Adapter for NGINX Service Mesh.\n\n---\n\n### Meshery Adapter for Traefik Mesh (beta)\n\n<img\n  src={Traefik}\n  alt=\"Traefik Mesh logo\"\n  style={{ float: \"left\", maxWidth: \"300px\", width: \"80%\", padding: \"1.25rem\" }}\n/>\n\nTraefik Mesh is a lightweight, non-invasive service mesh offering visibility and traffic management inside Kubernetes clusters.\n\nMeshery supports the lifecycle and performance management of Traefik Mesh, including multiple versions and bundled operations for Book Info and HttpBin sample applications.\n\nReview the  \n<a href=\"https://docs.meshery.io/guides/sample-apps\">sample application guides</a>  \nand learn more about the beta adapter for  \n<a href=\"https://docs.meshery.io/service-meshes\">Traefik Mesh</a>.\n\n---\n\n### Meshery Adapter for NGINX Service Mesh (alpha)\n\n<img\n  src={NGINXSM}\n  alt=\"NGINX Service Mesh logo\"\n  style={{ float: \"left\", maxWidth: \"200px\", padding: \"1.25rem\", marginRight: \"1.5rem\" }}\n/>\n\nNGINX Service Mesh (NSM) is powered by NGINX Plus and provides lightweight traffic management in Kubernetes.\n\nMeshery supports NSM lifecycle and performance management with bundled sample applications:\n\n<ul>\n  <li>Book Info</li>\n  <li>HTTPBin</li>\n  <li>Emojivoto</li>\n</ul>\n\nLearn more in the  \n<a href=\"https://docs.meshery.io/guides/sample-apps\">sample application guides</a>  \nand review the  \n<a href=\"https://docs.meshery.io/service-meshes\">NGINX Service Mesh adapter</a>.\n\n---\n\n## Integrating with Meshery: Using Extension Points\n\nMeshery is an extensible cloud-native management platform offering a variety of extension points that let integrators augment or modify its behavior.\n\n<div className=\"img-center\">\n  <a href={MesheryExtensibility} style={{ backgroundColor: \"transparent\" }}>\n    <img src={MesheryExtensibility} alt=\"Meshery extensibility diagram\" />\n  </a>\n</div>\n\n### Types of Extension Points\n\n- **Extensible Service Mesh Adapters** — bring your own service mesh  \n- **Extensible APIs** — plug in custom GraphQL resolvers  \n- **Extensible Load Generators** — or bring your own  \n- **Extensible Providers** — dynamic injection of remote extensions  \n\nProviders (local and remote) support:\n\n- Pluggable UI  \n- Pluggable backend  \n- Custom authN/authZ  \n- Long-term persistence  \n- Enhanced visualization  \n- Historical reporting  \n\nExplore Meshery extensibility at:  \n<a href=\"https://docs.meshery.io/extensibility\">docs.meshery.io/extensibility</a>\n\n---\n\n## MeshKit and Meshery Adapter Library\n\nMeshKit provides common models, abstractions, error handling, and utilities for Meshery and its components.\n\n### Meshery Adapter Library\n\n<div className=\"img-center\">\n  <a href={MesheryAdapterLibrary}>\n    <img src={MesheryAdapterLibrary} alt=\"Meshery Adapter Library diagram\" />\n  </a>\n</div>\n\n- Supplies common interfaces and default implementations  \n- Includes a mini-framework for building gRPC adapter servers  \n- Uses Viper-based configuration providers, which users may override  \n\nRead  \n<Link to=\"/community/members/michael-gfeller\">Michael Gfeller</Link>'s intro post:  \n<Link to=\"/blog/meshery/introducing-meshkit-and-the-meshery-adapter-library\">\n  Introducing MeshKit and the Meshery Adapter Library\n</Link>\n\n---\n\n## Meshery Operator\n\n<img\n  src={MesheryOperator}\n  alt=\"Meshery Operator diagram\"\n  style={{ float: \"left\", maxWidth: \"300px\", width: \"20%\", padding: \"1.25rem\" }}\n/>\n\nMeshery Operator is a Kubernetes-native controller providing cluster discovery, service catalog discovery, and NATS-based data streaming.\n\n<div style={{ display: \"flex\", width: \"100%\" }}>\n  <div style={{ textAlign: \"center\", flex: \"50%\" }}>\n    <a href={MesheryOperatorShot} style={{ backgroundColor: \"transparent\" }}>\n      <img src={MesheryOperatorShot} alt=\"Meshery Operator UI\" style={{ width: \"100%\" }} />\n    </a>\n  </div>\n\n  <ul style={{ flex: \"50%\" }}>\n    <li>Defines the MeshSync and Meshery Broker (NATS) custom resources</li>\n    <li>Provides cluster discovery and service catalog synchronization</li>\n    <li>Streams data throughout Meshery's components</li>\n  </ul>\n</div>\n\n---\n\n## MeshSync\n\n<div style={{ display: \"flex\" }}>\n  <img\n    src={MeshSync}\n    alt=\"MeshSync diagram\"\n    style={{ maxWidth: \"300px\", width: \"20%\", padding: \"1.25rem\" }}\n  />\n\n  <ul>\n    <li>\n      <a href=\"https://docs.meshery.io/concepts/architecture/meshsync\">\n        MeshSync is the heartbeat of Meshery\n      </a>\n      , synchronizing cluster and cloud state.\n    </li>\n    <li>Enables cloud-agnostic object modeling</li>\n    <li>Detects existing services and workloads and maintains an in-memory snapshot</li>\n    <li>Improves resilience across Meshery operations</li>\n  </ul>\n</div>\n\n---\n\n## Relational Database\n\nMeshery’s  \n<a href=\"https://docs.meshery.io/concepts/architecture/database\">relational database</a>  \nstores MeshSync data, preferences, and system settings. It serves as an ephemeral cache.\n\n<div className=\"img-center\">\n  <a href={MesheryDB}>\n    <img src={MesheryDB} alt=\"Meshery database diagram\" />\n  </a>\n</div>\n\nLearn more or contribute at  \n<a href=\"https://github.com/layer5io/meshsync\">github.com/layer5io/meshsync</a>.\n\n---\n\n## GraphQL Support\n\nMeshery now exposes GraphQL between the UI and Meshery Server, enabling clients to request exactly the data they need. Extension points allow custom resolvers and schema additions.\n\n---\n\n## Meshery CLI Enhancements\n\nThe beloved `mesheryctl` introduces:\n\n- `context` — manage multiple Meshery deployments  \n- `channel` — subscribe deployments to stable or edge release channels  \n\n### Managing Multiple Deployments\n\nMeshery now uses a `meshconfig` file describing multiple contexts across Docker hosts and Kubernetes clusters. Use:\n\n- `mesheryctl system context`\n\n\nto switch deployments instantly.\n\n### Subscribing to Release Channels\n\n`mesheryctl system channel` lets you choose the release channel for each deployment, enable or disable auto-updates, or pin versions manually.\n\nReview all commands at the  \n<a href=\"https://docs.meshery.io/reference/mesheryctl\">mesheryctl Command Reference</a>.\n\n---\n\n## On to v0.6.0\n\nReview the full list of enhancements in the  \n[Meshery Documentation](https://docs.meshery.io/).\n\nPlanning for v0.6.0 is complete, and the community's innovation cycle shows no sign of slowing down.\n\nSee the  \n<a href=\"https://github.com/layer5io/meshery/blob/master/ROADMAP.md\">Meshery roadmap</a>.\n\n---\n\n<div className=\"intro\">\n  If these topics excite you, come say “Hi” in the community\n  <a href=\"http://slack.layer5.io\"> Slack</a> — you’ll be warmly welcomed. 😀\n</div>\n\n</BlogWrapper>\n","frontmatter":{"title":"Announcing Meshery v0.5.0","subtitle":"","date":"April 19th, 2021","author":"Aisuko Li","thumbnail":{"extension":"webp","publicURL":"/static/8817162db307ec6582ad1a1f5aa71201/v0.5.0.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRlAAAABXRUJQVlA4IEQAAAAwAwCdASoUAAoAPtFUo0uoJKMhsAgBABoJZwC7AB6PNYoAAP7ZPPBqgHk9L8Rq4LOZeWzq4QQEHi3NCBc96JkEWIAAAA=="},"images":{"fallback":{"src":"/static/8817162db307ec6582ad1a1f5aa71201/1ff2c/v0.5.0.webp","srcSet":"/static/8817162db307ec6582ad1a1f5aa71201/ee7ce/v0.5.0.webp 750w,\n/static/8817162db307ec6582ad1a1f5aa71201/819dc/v0.5.0.webp 1080w,\n/static/8817162db307ec6582ad1a1f5aa71201/7b8ce/v0.5.0.webp 1366w,\n/static/8817162db307ec6582ad1a1f5aa71201/1ff2c/v0.5.0.webp 1500w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/8817162db307ec6582ad1a1f5aa71201/v0.5.0.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRlAAAABXRUJQVlA4IEQAAAAwAwCdASoUAAoAPtFUo0uoJKMhsAgBABoJZwC7AB6PNYoAAP7ZPPBqgHk9L8Rq4LOZeWzq4QQEHi3NCBc96JkEWIAAAA=="},"images":{"fallback":{"src":"/static/8817162db307ec6582ad1a1f5aa71201/cd5ef/v0.5.0.webp","srcSet":"/static/8817162db307ec6582ad1a1f5aa71201/f6072/v0.5.0.webp 125w,\n/static/8817162db307ec6582ad1a1f5aa71201/cb4bd/v0.5.0.webp 250w,\n/static/8817162db307ec6582ad1a1f5aa71201/cd5ef/v0.5.0.webp 500w,\n/static/8817162db307ec6582ad1a1f5aa71201/0f033/v0.5.0.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":250}}}},"fields":{"slug":"/blog/announcements/announcing-meshery-v050"}},{"id":"ea2400da-2d3b-59c7-be79-7831ba9fc7fc","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport operator from \"./meshery-operator-dark.svg\";\nimport MesheryArchitecture from \"./meshery-architecture.webp\";\n\n<BlogWrapper>\n\n[Meshery](https://meshery.io) is the cloud native management plane offering lifecycle, configuration and performance management of cloud native infrastructure and their workloads.\n\nLayer5 community members are hard at work providing our users with easy access to any cloud native infrastructureand myriad management features. New releases for Meshery are published on a frequent cadence with new features and bug fixes. Today, we are announcing version 0.4.0 of Meshery. This summary highlights Meshery's latest developments and elucidates new features.\n\n## What's New?\n\nThe v0.4.0 release of Meshery introduces a plethora of new features and bug fixes across cloud native infrastructure environments spanning Meshery and it's various adapters.\n\n### Meshery's CLI: `mesheryctl`\n**New Command Structure**<br/>\n`mesheryctl` commands and subcommands have been restructured in v0.4.0 into the categories:\n- Global Commands and Flags\n- Meshery Lifecycle Management\n- Performance Management\n- Infrastructure Lifecycle Management\n- Workload Lifecycle Management\n\nOrganizing commnands [under these categories](https://docs.meshery.io/reference/mesheryctl) is done with both the intention to make `mesheryctl` functions intuitively at your fingertips, but also to make room for forthcoming functionality.\n\n**Exposing Performance Management in the CLI**<br/>\n`perf:` a new `mesheryctl`command. Introduction of new performance sub-commands, now benchmark your cloud native infrastructure at the tip of your fingers using our new CLI command `perf`.\n\n**Support for Scoop** <br/>\nSupport extended to Scoop Bucket. You can now install mesheryctl on your Windows machine with Scoop Bucket. Visit the [Meshery Scoop Bucket](https://github.com/layer5io/scoop-bucket) to install Meshery on Windows.\n\n**Rename `cleanup` to `reset`**<br/>\nThe `cleanup` is used to reset your Meshery deployment configuration back to its default settings. This command has been renamed to `reset` to more appropriately reflect its purpose.\n\n### MeshSync<br/>\n<img src={operator} className=\"image-right\" alt=\"meshery-operator-dark\" />\n\n-  A component of the [Meshery Operator](https://github.com/layer5io/meshery-operator), MeshSync can scan the environment to get the deployment details of specific types of cloud native infrastructure and the connected Kubernetes cluster.\n-  MeshSync is a new component addition to Meshery. Meshery needs to be constantly updated given that cloud native infrastructure and their underlying infrastructure are dynamic, constantly changing.  Meshery operations should be resilient in the face of this change.\n-  MeshSync brings a infrastructure agnostic object model that defines relationships between all objects under management.\n\n### Meshery Adapter for Citrix Service Mesh (beta)<br/>\n\n<img src={MesheryArchitecture} className=\"image-right\" alt=\"meshery-architecture\" />\n\n- [Citrix Service Mesh](https://github.com/layer5io/meshery-cpx) is now a supported integration. Meshery incorporates support for the Citrix ADC CPX, which is a cloud-ready, container-based application delivery controller that can be provisioned on a Docker host.\n- CPX runs as the Istio Data Plane component, displacing Envoy as the default data plane service proxy.<br/>\n\n### Security & Authentication\n\n- Meshery has moved from using session authentication to JWT authentication. Meshery's JWT authentication is powered by Hydra Auth.\n- You can now opt to authenticate yourself on mesheryctl while performing performance tests using `mesheryctl`, you can authenticate yourself by getting the JWT Token from Meshery UI.\n\n### Meshery Server\n\n- Support provided for [wrk2 as an alternative load generator](https://docs.meshery.io/functionality/performance-management#load-generators).\n- [Providers](https://docs.meshery.io/extensibility) - A new project construct that allows users to select authentication, long-term storage etc.\n- Ad-hoc [connectivity tests for Prometheus and Grafana](https://docs.meshery.io/functionality/performance-management#grafana-and-meshery) are now supported.\n- Extraneous information beyond IP address and port in Grafana and Prometheus endpoints have been stripped off.\n\n### Meshery UI\n\n- ES-Lint has been added to the client side to ensure the quality of code and increase maintainaiblity of code.\n- Cypress has been set-up to enable end-to-end tests and integration tests for Meshery UI.\n\n<center><iframe frameBorder=\"0\" width=\"100%\" height=\"300\" allowfullscreen={true} mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"frameBorder=\"0\" width=\"100%\" height=\"300\" allowfullscreen={true} mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\" src=\"https://www.youtube.com/embed/ds9D2KgZKxo\" loading=\"lazy\"></iframe></center>\n\n\n### Other notable changes\n\n- From within the [Meshery Continuous Integration Working Group](https://www.youtube.com/watch?v=ds9D2KgZKxo&list=PL3A-A6hPO2IM7rYiKxG4l3eQNc6X3IUex), we have strengthened our continuous integration (CI) actions & tests by introducing new workflows like `static check`, `vet check`, `security check` for our server code.\n- ReleaseDrafter & WelcomeBot has been added to the repository to enable automation of release notes and for welcoming new contributors, respectively.\n\nTo get a more comprehensive list of the bug fixes and enhancements packaged in the v0.4.0 release, see the [Meshery Documentation](https://docs.meshery.io/project/releases)\n\n\n_**P.S.: If these topics excite you and you want to explore the beautiful realm of cloud native infrastructure, come and say \"Hi\" on our [Slack Channel](http://slack.layer5.io) and one of us will reach out to you!**_\n\n</BlogWrapper>\n","frontmatter":{"title":"Announcing Meshery v0.4.0","subtitle":"","date":"August 7th, 2020","author":"Layer5 Team","thumbnail":{"extension":"webp","publicURL":"/static/af2d9c15a09697b2ad48556b58102cd8/meshery-v040.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRsoAAABXRUJQVlA4WAoAAAAQAAAAEwAADAAAQUxQSGYAAAABgCsAgIHqqtHm5JrcZNvWxqvd2GwbYz1u7yf5ARGR4N+JIZRCqIZQBSQ+aIdJPY+dC3seH6nRZlTtfN27zv5n8B0Vs5jm+2qmdSqD7LBa0lUQRfBdDgvPIlGJVCQJR0JTiTjw/wBWUDggPgAAADADAJ0BKhQADQA+0VakS6gko6GwCAEAGglpAAB60b/b/AAA/vAi9+Ax+ANYXYVXicTSFmjmW1J3l211gAAA"},"images":{"fallback":{"src":"/static/af2d9c15a09697b2ad48556b58102cd8/921bf/meshery-v040.webp","srcSet":"/static/af2d9c15a09697b2ad48556b58102cd8/921bf/meshery-v040.webp 500w","sizes":"100vw"},"sources":[]},"width":1,"height":0.666}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/af2d9c15a09697b2ad48556b58102cd8/meshery-v040.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRsoAAABXRUJQVlA4WAoAAAAQAAAAEwAADAAAQUxQSGYAAAABgCsAgIHqqtHm5JrcZNvWxqvd2GwbYz1u7yf5ARGR4N+JIZRCqIZQBSQ+aIdJPY+dC3seH6nRZlTtfN27zv5n8B0Vs5jm+2qmdSqD7LBa0lUQRfBdDgvPIlGJVCQJR0JTiTjw/wBWUDggPgAAADADAJ0BKhQADQA+0VakS6gko6GwCAEAGglpAAB60b/b/AAA/vAi9+Ax+ANYXYVXicTSFmjmW1J3l211gAAA"},"images":{"fallback":{"src":"/static/af2d9c15a09697b2ad48556b58102cd8/921bf/meshery-v040.webp","srcSet":"/static/af2d9c15a09697b2ad48556b58102cd8/b6c82/meshery-v040.webp 125w,\n/static/af2d9c15a09697b2ad48556b58102cd8/48571/meshery-v040.webp 250w,\n/static/af2d9c15a09697b2ad48556b58102cd8/921bf/meshery-v040.webp 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":333}}}},"fields":{"slug":"/blog/announcements/announcing-meshery-v040"}}]}},"pageContext":{"tag":"Projects"}},"staticQueryHashes":["1485533831","4047814605","408154852","4152005505"],"slicesMap":{},"matchPath":"/blog/tag/projects"}