{"componentChunkName":"component---src-templates-blog-category-list-js","path":"/blog/category/meshery.html","result":{"data":{"allMdx":{"nodes":[{"id":"453ee1a4-6c53-5436-aa42-2a42163788f2","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport { Link } from \"gatsby\";\nimport Button from \"../../../../reusecore/Button\";\nimport FiveInstructions from \"./five-instructions.png\";\nimport FiveLegos from \"./five-legos.png\";\n\n<BlogWrapper>\n\n<div className=\"intro\">\n\nIn Meshery, two key concepts play a pivotal role in managing infrastructure and deployments: Meshery Models and Meshery Designs. Understanding their difference and their similarities will greatly increase your benefit from these two powerful, systems management paradigms.\n\n</div>\n\n<h3 style={{ marginTop: \"1.2rem\" }}>Meshery Models</h3>\n\n \n<h3 style={{ marginTop: \"1.2rem\" }}> Meshery Designs</h3>\n\nOn the other hand, <a href=\"https://docs.meshery.io/concepts/logical/designs\" target=\"_blank\" rel=\"noreferrer\">Meshery Designs</a> are the practical implementations based on Meshery Models. They represent declarations of your infrastructure deployments, customized according to specific use cases, environments, and requirements. Meshery Designs allow you to create, manage, and deploy complex architectures seamlessly, leveraging the power and flexibility of Meshery Models as their foundation.\n<img src={FiveLegos}  width=\"50%\" />\n<h3 style={{ marginTop: \"1.2rem\" }}><strong>Meshery Models (similar to Lego bricks)</strong></h3>\n\nMeshery <a href=\"https://docs.meshery.io/concepts/logical/models\" target=\"_blank\" rel=\"noreferrer\">Models</a> are standardized packages that bundle components and characterize their relationships. <a href=\"https://docs.meshery.io/concepts/logical/components\" target=\"_blank\" rel=\"noreferrer\">Components</a> are often representative of infrastructure, but can, in fact, represent anything (see semantically meaningful vs non-semantically meaingful components). Models uniformly wrap each component with a layer of metadata therein standardizing all entities (infrasturcture or otherwise) under a common interface much in the same way that the Industrial Revolution offered consistency of parts and interchangability of machinery, Meshery Components become fundamental building blocks. Components are like standard Lego bricks, window pieces, wheels that all snap together - or don't - depending upon way in which they relate to one another.\nAs versioned and portable pacakges, Models provide a structured, reusable, and extensible way to represent infrastructure components and their relationships, going beyond just code. This enables a more flexible and adaptable approach to modeling complex systems. are powerful Relationships and policies. contain Components cannot be directly used to build something complete on their own, but are standardized and reused across different Lego sets (instructions).\n<ul>\n\t<li><strong>Definition:</strong>&nbsp;Building blocks for infrastructure definition.</li>\n\t<li><strong>Focus:</strong>&nbsp;Describe how to manage specific infrastructure types and their interactions.<img data-file-id=\"2445161\" height=\"223\" src={FiveLegos} style={{ border: \"0px\", width: \"300px\", height: \"223px\", margin: \"0px\", boxShadow: \"none\" }} width=\"300\" className=\"image-right-no-shadow\" /></li>\n\t<li><strong>Content:</strong>&nbsp;Define properties, capabilities, and relationships for infrastructure components.</li>\n\t<li><strong>Usability:</strong>&nbsp;Not directly deployable, but used as building blocks within Designs.</li>\n\t<li><strong>Sharing:</strong>&nbsp;Can be packaged and shared for others to use in their Designs.</li>\n</ul>\n\nMeshery Models are like the individual Lego bricks - they define the building blocks for infrastructure with specific characteristics.\n<h3 style={{ marginTop: \"1.2rem\" }}><strong>Meshery Designs (similar to Lego instructions)</strong></h3>\n\nMeshery Designs provide a collaborative blueprint for building a specific model using Lego bricks (Meshery Models). Designs define the structure and placement of the bricks to achieve the desired outcome. Desan be shared, versioned, and used as reference for building the same model.\nIn essence:<img data-file-id=\"2445165\" height=\"300\" src={FiveInstructions} style={{ border: \"0px\", width: \"179px\", height: \"300px\", margin: \"0px\" }} width=\"179\" className=\"image-right-no-shadow\"/>\n<ul>\n\t<li><strong>Definition:</strong>&nbsp;Collaborative documents for infrastructure and application deployment.</li>\n\t<li><strong>Focus:</strong>&nbsp;Describe the desired state of infrastructure for a specific deployment.</li>\n\t<li><strong>Content:</strong>&nbsp;Use components (based on Models) and relationships to define your infrastructure.</li>\n\t<li><strong>Usability:</strong>&nbsp;Designs are the deployable unit in Meshery.</li>\n\t<li><strong>Sharing:</strong>&nbsp;Can be exported, versioned, shared, and published for reuse by others.</li>\n</ul>\n{/* <img src={FiveInstructions} className=\"img-right\" /> */}\nMeshery Designs are like the Lego instructions - they use Models (like bricks) to lay out the specific infrastructure deployment plan.\n<strong>Analogy:</strong> Think of Models as Lego bricks (defining types of pieces) and Designs as Lego instructions (defining how to build something specific). In summary, Meshery Models serve as the theoretical frameworks, while Meshery Designs translate these frameworks into tangible deployments, enabling you to design, deploy, and manage your infrastructure efficiently within the cloud and cloud native ecosystem.\n\n</BlogWrapper>\n","frontmatter":{"title":"Comparing Meshery Models and Meshery Designs","subtitle":"Lego Bricks and Lego Instructions","date":"March 27th, 2024","author":"Lee Calcote","thumbnail":{"extension":"png","publicURL":"/static/849957f6f940bb09802455b7e7411be8/five-legos.png","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD2klEQVR42h2SS2wbVRSGRxQJKUII8RKLik3XVEJdVUKgrEtZtSqLComHEAgWjcSCZoNATSmKRFpQihBIDUlJ6zR2Xk2cOI4T16nz8iN27InH4/f4/bjj8Tjjx4zvz42vdDb/vec75/zncvFZLpRZ4vL5zfOZsu87SRb/lNTsU0ktbEiy8LtUcl+SyNGwpERuSRn7eSm9xEll+0tSfv0NKbf+tpSzvSxJa1xGWuHyqadciCssc0TeOgN57316IgyjWzCh1/ACHQmgDRYq0FOQPLJga/4H7CwPIWL7GMrBIJT9DyC73wNxvUOV7VdRcQwQLmflalXnWdQ8n/Qa0VGqFVdpV41TQz+hPYbDKbLZpLGYSGu1Ou3ooNlcifo2Rmg98DUl3uu0tnepJ+8Oouy8WOPK2xdJw3cFCj9MNWkaXdmHni6fckDpKQ/I5/P9OD7mUZdJX4scB1EIjKEljkAJDNGT4Feo7X9KOCV0k7Tjo9DSU7RbdYFRoWkNKKqKTrvdT87mcvB4PAiHw2g2m30tlUqjEl+Bnp9BUxynbXEUjdBPhNMyJtKrrKJb26F6I8qeathxb2Nx1ox8odBPTkZFiIIAWZZRLBYZ9ATplAitEoBRfY62tEi7GRNU4QHh2sRP0Iqjp+Wo3qr1ATMLC7h260c4Nhw4OjzEHYsJiy4nBJ6HGItBYHBVqbJpCjDqx+iU9min4ISSWCFc66RI2A3zrc0M66HV0mBnoAtL/2DMvQZxZx/mgx3wqUS/WKlUgnVlBUqdecnyDDWHVkWgzWIApcRzwpF2k3TZArpGr78BUYhif92BhcV53J74G3fNJiRYV6lUihVr9UeORqMIHPqRy6TQ66ioVzO0mI8y3UO4mKaQMtVR73b6QBvvxzXrFD7/4kt8dPUqLjy6h60YD5XICIaOoCgNZLNZqI0GEvE4xGgEpWqRBpMRbAb3CLdek4i/LSOvt/qfJMCSPpudwDe/jmB87C5sz7YgJOMwDANJ1uXpybEvpGkadF2HGGeelgt0LujFfaeNcGOSr/KwKsAWC+r2tTXD8mjG8DldxvFh0Ah6vMb+1jPDPP3YsC4vGxazxfAzLRmPG3NzFmPTbjdSmYxhDnr0G/ZFXH7yb4W7HLOR6zkXbkQ26ETCiz+ibgyHHfgv4YNVimAy7sPtIwfGBTcmI3tYTYeRkcsIJ2P42TqHiegBPnRM09dmxvHiX78QbsAztfuK96HweuBx+N3wPH8u9IQf8E/x5wIm/qxvkn/L84B/MzDND0aW+O/TLn6IxbcstpUsH1AL/JWEneeWfwu/cP+mcObO0O7/6mKhlbD47xgAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/849957f6f940bb09802455b7e7411be8/ac427/five-legos.png","srcSet":"/static/849957f6f940bb09802455b7e7411be8/bfaac/five-legos.png 750w,\n/static/849957f6f940bb09802455b7e7411be8/abf2b/five-legos.png 1080w,\n/static/849957f6f940bb09802455b7e7411be8/ac427/five-legos.png 1200w","sizes":"100vw"},"sources":[{"srcSet":"/static/849957f6f940bb09802455b7e7411be8/1e5e2/five-legos.webp 750w,\n/static/849957f6f940bb09802455b7e7411be8/77f81/five-legos.webp 1080w,\n/static/849957f6f940bb09802455b7e7411be8/80d94/five-legos.webp 1200w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.6891666666666666}}},"darkthumbnail":{"extension":"png","publicURL":"/static/849957f6f940bb09802455b7e7411be8/five-legos.png","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD2klEQVR42h2SS2wbVRSGRxQJKUII8RKLik3XVEJdVUKgrEtZtSqLComHEAgWjcSCZoNATSmKRFpQihBIDUlJ6zR2Xk2cOI4T16nz8iN27InH4/f4/bjj8Tjjx4zvz42vdDb/vec75/zncvFZLpRZ4vL5zfOZsu87SRb/lNTsU0ktbEiy8LtUcl+SyNGwpERuSRn7eSm9xEll+0tSfv0NKbf+tpSzvSxJa1xGWuHyqadciCssc0TeOgN57316IgyjWzCh1/ACHQmgDRYq0FOQPLJga/4H7CwPIWL7GMrBIJT9DyC73wNxvUOV7VdRcQwQLmflalXnWdQ8n/Qa0VGqFVdpV41TQz+hPYbDKbLZpLGYSGu1Ou3ooNlcifo2Rmg98DUl3uu0tnepJ+8Oouy8WOPK2xdJw3cFCj9MNWkaXdmHni6fckDpKQ/I5/P9OD7mUZdJX4scB1EIjKEljkAJDNGT4Feo7X9KOCV0k7Tjo9DSU7RbdYFRoWkNKKqKTrvdT87mcvB4PAiHw2g2m30tlUqjEl+Bnp9BUxynbXEUjdBPhNMyJtKrrKJb26F6I8qeathxb2Nx1ox8odBPTkZFiIIAWZZRLBYZ9ATplAitEoBRfY62tEi7GRNU4QHh2sRP0Iqjp+Wo3qr1ATMLC7h260c4Nhw4OjzEHYsJiy4nBJ6HGItBYHBVqbJpCjDqx+iU9min4ISSWCFc66RI2A3zrc0M66HV0mBnoAtL/2DMvQZxZx/mgx3wqUS/WKlUgnVlBUqdecnyDDWHVkWgzWIApcRzwpF2k3TZArpGr78BUYhif92BhcV53J74G3fNJiRYV6lUihVr9UeORqMIHPqRy6TQ66ioVzO0mI8y3UO4mKaQMtVR73b6QBvvxzXrFD7/4kt8dPUqLjy6h60YD5XICIaOoCgNZLNZqI0GEvE4xGgEpWqRBpMRbAb3CLdek4i/LSOvt/qfJMCSPpudwDe/jmB87C5sz7YgJOMwDANJ1uXpybEvpGkadF2HGGeelgt0LujFfaeNcGOSr/KwKsAWC+r2tTXD8mjG8DldxvFh0Ah6vMb+1jPDPP3YsC4vGxazxfAzLRmPG3NzFmPTbjdSmYxhDnr0G/ZFXH7yb4W7HLOR6zkXbkQ26ETCiz+ibgyHHfgv4YNVimAy7sPtIwfGBTcmI3tYTYeRkcsIJ2P42TqHiegBPnRM09dmxvHiX78QbsAztfuK96HweuBx+N3wPH8u9IQf8E/x5wIm/qxvkn/L84B/MzDND0aW+O/TLn6IxbcstpUsH1AL/JWEneeWfwu/cP+mcObO0O7/6mKhlbD47xgAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/849957f6f940bb09802455b7e7411be8/cacd2/five-legos.png","srcSet":"/static/849957f6f940bb09802455b7e7411be8/3fa89/five-legos.png 125w,\n/static/849957f6f940bb09802455b7e7411be8/9a68e/five-legos.png 250w,\n/static/849957f6f940bb09802455b7e7411be8/cacd2/five-legos.png 500w,\n/static/849957f6f940bb09802455b7e7411be8/62029/five-legos.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/849957f6f940bb09802455b7e7411be8/621bc/five-legos.webp 125w,\n/static/849957f6f940bb09802455b7e7411be8/71bd9/five-legos.webp 250w,\n/static/849957f6f940bb09802455b7e7411be8/cde0b/five-legos.webp 500w,\n/static/849957f6f940bb09802455b7e7411be8/b9e32/five-legos.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":345}}}},"fields":{"slug":"/blog/meshery/comparing-meshery-models-and-meshery-designs"}},{"id":"3f9938ec-1672-5660-a41a-09aba90884e4","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport { Link } from \"gatsby\";\nimport Button from \"../../../../reusecore/Button\";\nimport MeshMarkFormula from \"./meshmark-formula.png\";\nimport MeshMark from \"./meshmark.png\";\nimport Catalog from \"./catalog.png\";\nimport NighthawkSlide from \"./nighthawk-slide.png\";\nimport SMPSpec from \"./smp-spec.png\";\nimport Booth from \"./booth.png\";\n\n<BlogWrapper>\nHappy KubeCon week! We hope you are as excited as we are about all the fantastic things we will learn.\n\nZack and Nic are here in Paris representing TAG Network; today at 2:30. They have a lightning talk, and every afternoon, the TAG Network booth will be open for business!\n\n\nWe're excited to connect with you in person at KubeCon EU! You can find us at kiosk **PP19-A**, located in the **Solutions Showcase | Level 7.2 | Hall 7.2 | Project Pavilion**.\n\nAt the booth, we'll be showcasing demos of our two newest projects:\n\n* **Applying for Sandbox Status:** Learn how to easily apply for Sandbox status for your innovative cloud-native networking project.\n* **ConnectRPC:** Discover a revolutionary new approach to service mesh interoperability with ConnectRPC.\n* **KubeSlice:** Dive into the world of network slicing with KubeSlice, designed for optimal network resource utilization.\n\n<div style={{ display: \"flex\", alignItems: \"center\" }}>\n<h2> Don't forget to catch our lightning talk today at 2:30! </h2>\n<img src={Booth} width=\"400\" />\n</div>\n\n<p />\n\nWhether you're interested in these projects, have questions about the TAG Network, or simply want to chat about cloud-native networking, we'd love to see you! Drop by our booth for a coffee and a conversation â€“ we look forward to meeting you!\n\n\n## Building a Strong Foundation: The TAG Network Mission\n\nThe TAG Network, led by Lee Calcote (Layer5), Nic Jackson (HashiCorp), Zack Butcher (Tetrate), and technical lead Zhonghu Xu (Huawei), is dedicated to empowering the cloud native community. Their mission is fourfold:\n\n* **Clarity and Education:** Providing developers and operators with the knowledge and guidance they need to navigate cloud native networking.\n* **Collaboration and Integration:** Fostering collaboration between network projects and other CNCF initiatives for a unified ecosystem.\n* **Project Growth and Adoption:** Supporting the development and widespread adoption of promising network projects within the CNCF landscape.\n* **Neutral Stewardship:** Ensuring a fair and open environment for innovation in cloud native networking.\n\n## A Look Back: Tracking Progress Through KubeCon Events\n\nThe TAG Network and Service Mesh WG have a strong presence at KubeCon events, showcasing the evolution of cloud native networking:\n\n* **KubeCon NA 2019:** This marked the introduction of foundational projects like CNI (Container Network Interface), CoreDNS, Envoy, and Linkerd, laying the groundwork for future advancements.\n* **KubeCon Throughout 2020 & 2021:** The focus shifted towards service mesh adoption, with projects like BFE, Istio, SMI (Service Mesh Interface), and Meshery taking center stage, empowering developers to manage complex microservices architectures.\n* **Recent KubeCon Events:** The latest gatherings highlighted cutting-edge projects like GetNighthawk (performance analysis), KubeSlice (network slicing), and Connect (service mesh interoperability), demonstrating the continuous push for innovation.\n\n## Unveiling Service Mesh Patterns: Reusability Meets Best Practices\n\nThe Service Mesh WG champions the concept of service mesh patterns, a collection of reusable architectural building blocks designed for:\n\n* **End-User Focus:** Explained in clear language, these patterns are independent of specific service meshes, making them easy to understand and implement.\n* **Flexibility:** While core functionality remains consistent, users can leverage features specific to their chosen service mesh for even greater control.\n* **Reusability:** Patterns are designed to be easily copied, modified, and combined to create complex solutions tailored to your specific needs.\n* **Best Practices Integration:** Each pattern incorporates recommended practices for optimal network design, ensuring a solid foundation for your cloud native applications.\n\nExplore the extensive service mesh pattern library at [https://meshery.io/catalog](https://meshery.io/catalog) to discover a treasure trove of reusable solutions for your cloud native network.\n\n<img src={Catalog} />\n<p/>\n\n## Nighthawk Takes Flight: Distributed Performance Analysis\n\nThe Service Mesh Performance initiative tackles the challenge of accurately measuring service mesh performance under load. Enter Nighthawk, a distributed performance analysis tool that empowers you to:\n\n* Generate realistic load scenarios that mimic real-world traffic patterns for a more accurate picture of your network's behavior.\n* Gain valuable insights into system behavior under pressure, allowing you to make informed decisions about configuration and optimization.\n* Compare performance across different service mesh deployments and configurations to identify the best fit for your specific needs.\n\n<img src={NighthawkSlide} />\n<p/>\n\n## Standardization Efforts: MeshMark and the SMP Spec\n\nThe CNCF TAG Network actively promotes standardization within the cloud native networking space. Two key initiatives are:\n\n #### **MeshMark:** \n <a href=\"https://smp-spec.io/meshmark\">MeshMark</a> serves as a performance index gauging the significance and overhead within your cloud native ecosystem. By transforming performance metrics into actionable insights regarding the significance of individual networking functions within cloud native applications, MeshMark consolidates diverse overhead signals and crucial performance metrics into a straightforward index.\n<img src={MeshMark} />\n\n<img src={MeshMarkFormula} />\n\n<p />\n\n #### **SMP Spec (Service Mesh Performance Specification):**  \n This initiative establishes a vendor-neutral standard for measuring and reporting service mesh performance. This standardization paves the way for consistent performance comparisons and facilitates informed service mesh selection.\n<img src={SMPSpec} />\n<p/>\n\n\n## Join the Movement: Get Involved!\n\nThe CNCF TAG Network and Service Mesh WG are open communities that thrive on collaboration. Here's how you can contribute:\n\n* Attend their bi-weekly meetings on the 1st and 3rd Thursdays of each month at 11 AM Pacific Time.\n* Stay informed by reading meeting minutes on the CNCF website.\n* Connect with the community on the #tag-network Slack channel and share your experiences and ideas.\n* Subscribe to the cncf-sig-network-servicemesh-wg mailing list for updates and announcements.\n\nBy actively participating in these initiatives, you can play a vital role in shaping the future of resilient and intelligent cloud native networks\n\n</BlogWrapper>\n","frontmatter":{"title":"Layer5 at KubeCon EU 2024","subtitle":"Deep Dive into Cloud Native Networking with CNCF TAG Network & Service Mesh WG","date":"March 20th, 2024","author":"Ritik Saxena","thumbnail":{"extension":"png","publicURL":"/static/674405e0d6e0490ebefae7e93a644744/kubeconeu2024.png","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACiklEQVR42mPwsyr1tSxxN8r3sSgGsoHI26zYw6TQ2xzKhSB/m3J3/dzYgLbS/DluXq0BqbOCS5YyAPWEOVd31y2N8Wrwsy4F6kkL7WgonJ0c2OplVuRvXepnXeZvWeqpl52ZOnXbzdePfvybff9rwo0fUdd/MniaFiYFtp48dLWlbL63WZGHcUFZ2uS+puXFKZNc9PMCbMt9TQoC7Cv9OndOv/911ZOvB+69PffiS8a5dxHnPjEA3Qy0s7NmcUZYJ9B5QHZOTE9T6bzc2N4Y70agzrDAjtzd92Pv/Im69MV3613nmcc8Vl0JO/oq+tIXoObSeJ+mlKC2pIBWoP7qnBkt5Qvy4voyIrrSA1vCw3urzr6pePA3+uyH6MtfY698AzJCT74NPvsx4tJXBj+LEh/TIh8zEAJ6PtixKtih0t+mzFkzw82uqvzEi8b7v8sufYy69j1j94PE0+8irn5vuPdj3es/qde+Mfg6Vfs5A1ENEPlYlfka5ftZlnhblJTmzVpw5knt/T8V9/4UPvwXfPd/wYITiYefh139XnztS9vhB2ln3zG4zzgARx4T93gXLfJ3qPQzzm+ec2D1ox8NF98uWnVo0exNVSeflM04lL/tdsqT/5HHX/ld+Bp97QeD69qLcOS2+oLb2ose3Vt9bcoLN97wX3cwPbZ9j19Kl1vmvLTGYve6hsrlkVP2hnjVL+lYOPPAdQavvPlQlDvPo3Or29LTLsvPhPbvDp6/mXtRY1Ry8Z3WmpScfu2q1RXiUVN0EsoSqpuTa246+ayNrGDwMy1EIKtSz84tTsvPRK6+MO3g7pbLuzdfPPZ619bde4/2nLyzeePR+/sOntl/4P7Vk+/3bjvftwAAvKBZWJKhLU0AAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/674405e0d6e0490ebefae7e93a644744/87706/kubeconeu2024.png","srcSet":"/static/674405e0d6e0490ebefae7e93a644744/0dee1/kubeconeu2024.png 750w,\n/static/674405e0d6e0490ebefae7e93a644744/8beaa/kubeconeu2024.png 1080w,\n/static/674405e0d6e0490ebefae7e93a644744/87706/kubeconeu2024.png 1280w","sizes":"100vw"},"sources":[{"srcSet":"/static/674405e0d6e0490ebefae7e93a644744/a66aa/kubeconeu2024.webp 750w,\n/static/674405e0d6e0490ebefae7e93a644744/65dd5/kubeconeu2024.webp 1080w,\n/static/674405e0d6e0490ebefae7e93a644744/71d4d/kubeconeu2024.webp 1280w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5625}}},"darkthumbnail":{"extension":"png","publicURL":"/static/674405e0d6e0490ebefae7e93a644744/kubeconeu2024.png","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACiklEQVR42mPwsyr1tSxxN8r3sSgGsoHI26zYw6TQ2xzKhSB/m3J3/dzYgLbS/DluXq0BqbOCS5YyAPWEOVd31y2N8Wrwsy4F6kkL7WgonJ0c2OplVuRvXepnXeZvWeqpl52ZOnXbzdePfvybff9rwo0fUdd/MniaFiYFtp48dLWlbL63WZGHcUFZ2uS+puXFKZNc9PMCbMt9TQoC7Cv9OndOv/911ZOvB+69PffiS8a5dxHnPjEA3Qy0s7NmcUZYJ9B5QHZOTE9T6bzc2N4Y70agzrDAjtzd92Pv/Im69MV3613nmcc8Vl0JO/oq+tIXoObSeJ+mlKC2pIBWoP7qnBkt5Qvy4voyIrrSA1vCw3urzr6pePA3+uyH6MtfY698AzJCT74NPvsx4tJXBj+LEh/TIh8zEAJ6PtixKtih0t+mzFkzw82uqvzEi8b7v8sufYy69j1j94PE0+8irn5vuPdj3es/qde+Mfg6Vfs5A1ENEPlYlfka5ftZlnhblJTmzVpw5knt/T8V9/4UPvwXfPd/wYITiYefh139XnztS9vhB2ln3zG4zzgARx4T93gXLfJ3qPQzzm+ec2D1ox8NF98uWnVo0exNVSeflM04lL/tdsqT/5HHX/ld+Bp97QeD69qLcOS2+oLb2ose3Vt9bcoLN97wX3cwPbZ9j19Kl1vmvLTGYve6hsrlkVP2hnjVL+lYOPPAdQavvPlQlDvPo3Or29LTLsvPhPbvDp6/mXtRY1Ry8Z3WmpScfu2q1RXiUVN0EsoSqpuTa246+ayNrGDwMy1EIKtSz84tTsvPRK6+MO3g7pbLuzdfPPZ619bde4/2nLyzeePR+/sOntl/4P7Vk+/3bjvftwAAvKBZWJKhLU0AAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/674405e0d6e0490ebefae7e93a644744/86bab/kubeconeu2024.png","srcSet":"/static/674405e0d6e0490ebefae7e93a644744/e1b03/kubeconeu2024.png 125w,\n/static/674405e0d6e0490ebefae7e93a644744/81b70/kubeconeu2024.png 250w,\n/static/674405e0d6e0490ebefae7e93a644744/86bab/kubeconeu2024.png 500w,\n/static/674405e0d6e0490ebefae7e93a644744/8cf60/kubeconeu2024.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/674405e0d6e0490ebefae7e93a644744/46142/kubeconeu2024.webp 125w,\n/static/674405e0d6e0490ebefae7e93a644744/81c3e/kubeconeu2024.webp 250w,\n/static/674405e0d6e0490ebefae7e93a644744/cd07d/kubeconeu2024.webp 500w,\n/static/674405e0d6e0490ebefae7e93a644744/bf95e/kubeconeu2024.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":281}}}},"fields":{"slug":"/blog/meshery/layer5-at-kubecon-eu-2024"}},{"id":"3e0d7c81-4e1a-5d6a-8b10-091398efd4fb","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport { Link } from \"gatsby\";\nimport Button from \"../../../../reusecore/Button\";\nimport CTA_FullWidth from \"../../../../components/Call-To-Actions/CTA_FullWidth\";\nimport CTAImg from \"../../../../assets/images/meshery/icon-only/meshery-logo-shadow.webp\"\n\n<BlogWrapper>\nContainers provide a lightweight and portable solution to package applications, making them easy to deploy across different environments. With Docker as the most popular container engine and image format, but not the only runtime or format, the need for a standardized format to store and distribute container images became apparent and is why the <a href=\"https://opencontainers.org\">Open Container Initiative</a> (OCI) image format comes into play.\nThe OCI was established as a community-driven initiative to create open standards for container formats and runtimes. Its goal is to promote interoperability and ensure that containers can be used across different platforms and runtime environments. One of the key components of the OCI initiative is the OCI image format, which has been widely adopted by container registries.\n\n<div className=\"intro\">\nWhy have container registries have embraced the OCI format? How does Meshery, a popular internal developer platform, leverage this format for pushing and pulling design patterns? By understanding the benefits of OCI format for container registries and Meshery's support for it, we can gain valuable insights into the advantages of using this standardized format.\n</div>\n\n## Why Container Registries Use OCI Format\n\nContainer registries play a crucial role in the container ecosystem, serving as repositories for storing and distributing container images. These images are the building blocks of containerized applications, containing everything needed to run an application, from the code to the dependencies and configurations. In recent years, container registries have widely adopted the Open Container Initiative (OCI) format as the standard for packaging and distributing container images.\n\n### Benefits of OCI Format\n\nThe adoption of OCI format by container registries offers several compelling benefits. Firstly, the OCI format provides a standardized and vendor-neutral way to package and distribute container images. This standardization ensures that images created using one container runtime can be run using a different runtime without any compatibility issues. This portability not only enhances interoperability but also encourages collaboration and innovation within the container ecosystem.\n\nSecondly, the OCI format promotes transparency and openness. It allows developers and users to inspect and understand the contents of a container image easily. By providing a clear structure for storing metadata and file system layers, the OCI format enables greater visibility into the image's composition, making it easier to identify potential security vulnerabilities or licensing issues.\n\n### Interoperability with Different Container Runtimes\n\nAnother key reason why container registries prefer the OCI format is its compatibility with various container runtimes. Since container runtimes are responsible for executing the container images, it is crucial to have a format that can work seamlessly across different runtime environments. The OCI format achieves this by defining a set of specifications that are implemented by various container runtimes like Docker, containerd, and CRI-O. This compatibility ensures that container images stored in OCI format can be executed on different runtimes, giving developers the flexibility to choose the runtime that best suits their needs.\n\n### Security and Trustworthiness\n\nSecurity is a top concern for container registries, and the OCI format offers robust security features. By adhering to the OCI format, container registries can leverage the security mechanisms provided by OCI specifications. These mechanisms include content-addressable storage, which ensures that the integrity of the image is maintained throughout its lifecycle, and digital signatures, which enable image verification and establish trust between the registry and the consumers. The use of the OCI format adds an additional layer of trustworthiness to container images, assuring users that the images have not been tampered with and come from a trusted source.\n\n## How Meshery Design Patterns Utilize OCI Format\n\n### Introduction to Meshery\n\nMeshery, an open-source service mesh management plane, has rapidly gained popularity among developers and operators for its ability to simplify and streamline the deployment, management, and observability of service meshes. One of the key features that sets Meshery apart is its utilization of the Open Container Initiative (OCI) format for pushing and pulling design patterns.\n\n### Advantages of Pushing and Pulling Design Patterns in OCI Format\n\nUsing the OCI format for design patterns offers several advantages for Meshery users. Firstly, it ensures that design patterns can be easily shared and reused across different container runtimes, regardless of the specific implementation details. This interoperability simplifies the process of deploying applications on various platforms, eliminating the need for time-consuming modifications and customizations.\n\nSecondly, the OCI format enhances security and trustworthiness by providing a standardized and verifiable way to package and distribute design patterns. By utilizing cryptographic signing, developers can ensure the integrity and authenticity of the design patterns they push and pull from container registries. This prevents tampering and reduces the risk of running malicious or compromised design patterns, enhancing the overall security posture of applications deployed using Meshery.\n\nAnother advantage of the OCI format is its ability to encapsulate not only the application code but also the underlying dependencies and runtime environment. This self-contained nature simplifies the process of distributing and maintaining design patterns, as all the necessary components are bundled together. It also allows for more consistent and reproducible deployments, ensuring that the design pattern behaves consistently regardless of the environment in which it is deployed.\n<>\n<CTA_FullWidth \n  image={CTAImg}\n  heading=\"Where DevOps Collaborates\"\n  alt=\"Meshery is a self-service engineering platform.\"\n  content=\"As a self-service engineering platform, Meshery enables collaborative design and operation of cloud and cloud native infrastructure.\"\n  button_text=\"See Meshery\"\n  url=\"/cloud-native-management/meshery\"\n  external_link={false}\n/>\n</>\n## Meshery's Support for OCI Format\n\nMeshery fully embraces the use of OCI format for pushing and pulling design patterns. It provides a seamless integration with container registries that support OCI, enabling users to easily discover, share, and deploy design patterns. Meshery's user-friendly interface allows developers and operators to browse the available design patterns, inspect their metadata, and quickly deploy them to their service mesh environments.\n\nFurthermore, Meshery's support for OCI format extends beyond just deploying design patterns. It also provides tools and capabilities to manage the lifecycle of these patterns, including versioning, updating, and deprecating. This ensures that users can easily keep track of the design patterns they utilize and stay up to date with the latest releases and improvements.\n\n## Conclusion\n\nIn conclusion, the adoption of OCI format by container registries and its integration within Meshery's design pattern management brings numerous benefits to the world of collaborative application infrastructure management. The use of OCI format ensures compatibility across different container runtimes, enhances security and trustworthiness, and simplifies the distribution and management of design patterns. With Meshery's support for OCI format, developers and operators can leverage these advantages to streamline and optimize their service mesh environments, ultimately improving the efficiency and reliability of their applications.\n\n\n\nahead of the curve and leverage the latest advancements. Learn about <a href=\"https://docs.meshery.io/extensibility\">Meshery's extensibility</a>. \n\n\n\n\n</BlogWrapper>","frontmatter":{"title":"Making Container Registries a home for Meshery Designs","subtitle":"The ubiquity of the OCI format","date":"February 24th, 2024","author":"Lee Calcote","thumbnail":{"extension":"png","publicURL":"/static/e8b45c76653bb060564418fca6d0714d/oci-images-meshery.png","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEQklEQVR42qWU+0/TVxiH++8t+2nZlmxLtizMuYtM3eYGIlKtOiyKpTCg7aDUUlt6A4q9SW2h5Y4gDNYqF4sjSCkttLXIrZdnp7Bk6sy2ZCc555s35z3Peb/v+56PpMh/GyW/YrF4PP+03zQkxdcO/d9xDCz+hSpFkMsXyBcKHOTy7B4ckNrZIZ7O8PtmkqVYnPXtNJvCTmWzPBd7W+k0+8LvCFhaEmKz3mDDEBhDH5pCFxhFNzCOLvgA3dAU+tEZrLMLmCbn0fiGUToDyG0epCYnVUYX5WoLQ/OPXwJmX3BJpUPXaUBv0GM1ttGmVnBLpaKzz0u7w8vFRjXfXLnBRzU3KNP08NkvDr61BKiyeDmndzAceXIMzOdybKSf02Dqocd8B5+zm1H/XYKubtrllZhb5Vg7WlHUybh6sYKvFO1cMDpRaHXU9A1h73fQYrMSiqwcA3O5w6OctNpdjAYD+D3djPTbeRhyYW2W0WNsR6/VYOy6Q2TMRUVbF52DIRZm7iPtHcTuddBksTEYiR4DDw8PjoDau/0EA/cJPwyysTxBLDpNn66e/rtWRvxOBsSMPZmgUmtF57vPg0ErFWYfTUYblxpaGJxbOAYWCnnWktuobC4CgQCTQz7C4x5WI8PYtQ3cc5hx95pR3rpOZMhEhcaA0uLA3qXnzG0n5YoOTtXUYnG6RYcUxC8fHrIiWkFl9xCZe4i+y4jPbWPeb2TYWMuSX8Pt5qs0NikZMDfw5fWfkWq7kTepKVMaKGu18vGlBuSNLaxsJI+Lsrz2jNoOC8FQiNGRARYfTTM74sWjqWHRLuVO/feUnfgUk+oqp2V1lFVf5/3zcj6p1/OerIWTta2oRVFDs4+RpNMputwWPq+6jExaLapsZ8LvQHHxNH2qSjaCN5lyq3F7RB4HvJyXKzlx4SfelWl4+wc5VW02vLNLjP+2xNO1dSTZ5xlUJgvvnPqR7858TV3lF3QppSwM62BvknzmAamFXsYs9fR01FNec43y6iu8dfYaN0UPji5v4B2bYSm6Qlq8GMmT5SihiRkazB6qmju43NRMc2s94WkX+dQYa5EBJkMmBp1tuNuvcLKimvKKC2hdQYYWY/QOjvFrOMxc+BHxRAJJIpEktr7OtjCePovhmw6j9gwjM/RR02agVjT0rcYqatVKbmvVfHD2PFJFC/65KMGZCJubm6yJGjxdXSMn6iEpLS92d0kI4Avx2LPpbTLbW6xtxPGX4HYvrnv91Km0fHhOxjWtjZH5Rcz+cabmIuyIM3EBzYpvSVhEHxZJpdJkMhmyQjlSIg/Jre0jh72dLOntJCOT03Q6+nGGJsns7LIZj7McjbKwJAqxunp0phTYK3pYEHK1t7dHWoBLm4eiP5/FYkeJ3hEXJRKbbCWTws6Qz+cpiGhKQZTs/f39NwvsKwr9mkaWLiwUi2/0e9n3b8B/kvdi8d81/Q81f05JaSiIpwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/e8b45c76653bb060564418fca6d0714d/b5658/oci-images-meshery.png","srcSet":"/static/e8b45c76653bb060564418fca6d0714d/f054e/oci-images-meshery.png 750w,\n/static/e8b45c76653bb060564418fca6d0714d/b5658/oci-images-meshery.png 1024w","sizes":"100vw"},"sources":[{"srcSet":"/static/e8b45c76653bb060564418fca6d0714d/4f03f/oci-images-meshery.webp 750w,\n/static/e8b45c76653bb060564418fca6d0714d/67ded/oci-images-meshery.webp 1024w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":1}}},"darkthumbnail":{"extension":"png","publicURL":"/static/e8b45c76653bb060564418fca6d0714d/oci-images-meshery.png","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEQklEQVR42qWU+0/TVxiH++8t+2nZlmxLtizMuYtM3eYGIlKtOiyKpTCg7aDUUlt6A4q9SW2h5Y4gDNYqF4sjSCkttLXIrZdnp7Bk6sy2ZCc555s35z3Peb/v+56PpMh/GyW/YrF4PP+03zQkxdcO/d9xDCz+hSpFkMsXyBcKHOTy7B4ckNrZIZ7O8PtmkqVYnPXtNJvCTmWzPBd7W+k0+8LvCFhaEmKz3mDDEBhDH5pCFxhFNzCOLvgA3dAU+tEZrLMLmCbn0fiGUToDyG0epCYnVUYX5WoLQ/OPXwJmX3BJpUPXaUBv0GM1ttGmVnBLpaKzz0u7w8vFRjXfXLnBRzU3KNP08NkvDr61BKiyeDmndzAceXIMzOdybKSf02Dqocd8B5+zm1H/XYKubtrllZhb5Vg7WlHUybh6sYKvFO1cMDpRaHXU9A1h73fQYrMSiqwcA3O5w6OctNpdjAYD+D3djPTbeRhyYW2W0WNsR6/VYOy6Q2TMRUVbF52DIRZm7iPtHcTuddBksTEYiR4DDw8PjoDau/0EA/cJPwyysTxBLDpNn66e/rtWRvxOBsSMPZmgUmtF57vPg0ErFWYfTUYblxpaGJxbOAYWCnnWktuobC4CgQCTQz7C4x5WI8PYtQ3cc5hx95pR3rpOZMhEhcaA0uLA3qXnzG0n5YoOTtXUYnG6RYcUxC8fHrIiWkFl9xCZe4i+y4jPbWPeb2TYWMuSX8Pt5qs0NikZMDfw5fWfkWq7kTepKVMaKGu18vGlBuSNLaxsJI+Lsrz2jNoOC8FQiNGRARYfTTM74sWjqWHRLuVO/feUnfgUk+oqp2V1lFVf5/3zcj6p1/OerIWTta2oRVFDs4+RpNMputwWPq+6jExaLapsZ8LvQHHxNH2qSjaCN5lyq3F7RB4HvJyXKzlx4SfelWl4+wc5VW02vLNLjP+2xNO1dSTZ5xlUJgvvnPqR7858TV3lF3QppSwM62BvknzmAamFXsYs9fR01FNec43y6iu8dfYaN0UPji5v4B2bYSm6Qlq8GMmT5SihiRkazB6qmju43NRMc2s94WkX+dQYa5EBJkMmBp1tuNuvcLKimvKKC2hdQYYWY/QOjvFrOMxc+BHxRAJJIpEktr7OtjCePovhmw6j9gwjM/RR02agVjT0rcYqatVKbmvVfHD2PFJFC/65KMGZCJubm6yJGjxdXSMn6iEpLS92d0kI4Avx2LPpbTLbW6xtxPGX4HYvrnv91Km0fHhOxjWtjZH5Rcz+cabmIuyIM3EBzYpvSVhEHxZJpdJkMhmyQjlSIg/Jre0jh72dLOntJCOT03Q6+nGGJsns7LIZj7McjbKwJAqxunp0phTYK3pYEHK1t7dHWoBLm4eiP5/FYkeJ3hEXJRKbbCWTws6Qz+cpiGhKQZTs/f39NwvsKwr9mkaWLiwUi2/0e9n3b8B/kvdi8d81/Q81f05JaSiIpwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/e8b45c76653bb060564418fca6d0714d/82c11/oci-images-meshery.png","srcSet":"/static/e8b45c76653bb060564418fca6d0714d/2fd20/oci-images-meshery.png 125w,\n/static/e8b45c76653bb060564418fca6d0714d/de391/oci-images-meshery.png 250w,\n/static/e8b45c76653bb060564418fca6d0714d/82c11/oci-images-meshery.png 500w,\n/static/e8b45c76653bb060564418fca6d0714d/13677/oci-images-meshery.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/e8b45c76653bb060564418fca6d0714d/d66e1/oci-images-meshery.webp 125w,\n/static/e8b45c76653bb060564418fca6d0714d/e7160/oci-images-meshery.webp 250w,\n/static/e8b45c76653bb060564418fca6d0714d/5f169/oci-images-meshery.webp 500w,\n/static/e8b45c76653bb060564418fca6d0714d/3cd29/oci-images-meshery.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":500}}}},"fields":{"slug":"/blog/meshery/making-container-registries-a-home-for-meshery-designs"}},{"id":"3114743c-320f-56c3-802e-716942ab4771","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\n\n<BlogWrapper>\nKubernetes provides robust RBAC (Role-Based Access Control) capabilities to manage access and authorization within a cluster. This allows you to control and restrict permissions for various resources. In this blog post, we will explore the process of binding a Kubernetes Service Account with a ClusterRole. We will also discuss how Meshery, a service mesh management tool, can be utilized to streamline the lifecycle management of Kubernetes clusters using MeshMap visual diagrams.\n<h2>Prerequisites</h2> \n\nBefore we delve into the details, ensure that you have the following prerequisites in place:\n<ol>\n  <li>Access to a running Kubernetes cluster.</li> \n  <li><code>kubectl</code>, the Kubernetes command-line tool, installed and configured to communicate with your cluster.</li>\n  <li>Meshery, the cloud native manager, installed and <a href=\"https://docs.meshery.io/installation/quick-start\">set up</a> on your local machine.</li>\n</ol>\n\n<h2>Binding a Kubernetes Service Account with ClusterRole:</h2>\n\nTo bind a Service Account with a ClusterRole, follow the steps outlined below:\n<strong>Step 1: Create a Service Account</strong>\nFirst, we need to create a Service Account that we will later bind to a ClusterRole. Use the following kubectl command to create a Service Account named <code>my-service-account</code>:\n<pre><code>sh kubectl create serviceaccount my-service-account</code></pre>\n<br />\n<strong>Step 2: Create a ClusterRole</strong>\nNext, let's create a ClusterRole that defines the desired permissions. You can either create a new ClusterRole or use an existing one. For the purpose of this example, we will create a ClusterRole named <code>my-cluster-role</code> that has read-only access to Pods and Services:\n```yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: my-cluster-role\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"services\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n```\n<br />\nSave the above YAML definition to a file named <code>clusterrole.yaml</code>, and create the ClusterRole using the following command:\n<pre><code>bash kubectl apply -f clusterrole.yaml</code></pre>\n<br />\n<strong>Step 3: Bind the Service Account with ClusterRole</strong>\nFinally, we need to bind the Service Account <code>my-service-account</code> with the ClusterRole <code>my-cluster-role</code>. This can be achieved by creating a ClusterRoleBinding. Execute the following command to create the binding:\n<pre><code>bash kubectl create clusterrolebinding my-cluster-role-binding --clusterrole=my-cluster-role --serviceaccount=default:my-service-account</code></pre>\n<br />\nThe above command creates a ClusterRoleBinding named <code>my-cluster-role-binding</code> that associates the Service Account <code>my-service-account</code> with the ClusterRole <code>my-cluster-role</code>.\n<strong>Verification:</strong>\nTo verify the successful binding, you can use the following command to check the ClusterRoleBinding:\n<pre><code>bash kubectl describe clusterrolebinding my-cluster-role-binding</code></pre>\n<br />\nYou should see the Service Account and ClusterRole information listed under the <code>Subjects</code> and <code>RoleRef</code> sections, respectively.\n<h2>Using Meshery and MeshMap for Kubernetes Cluster Lifecycle Management:</h2>\nMeshery is a powerful service mesh management tool that simplifies the management and operation of service meshes, including <a href=\"https://layer5.io/blog/meshery/multi-cluster-kubernetes-management-with-meshery\" target=\"_blank\" rel=\"noreferrer\">Kubernetes clusters</a>. MeshMap, a visual diagram feature of Meshery, provides a graphical representation of the service mesh components and their interactions.\nTo utilize Meshery and MeshMap for Kubernetes cluster lifecycle management, follow these steps:\n<strong>Step 1: Install Meshery</strong>\nRefer to the official Meshery <a href=\"https://docs.meshery.io/installation/quick-start\" target=\"_blank\" rel=\"noreferrer\">documentation</a> to install Meshery on your local machine or within your Kubernetes cluster.\n<strong>Step 2: Connect to Your Kubernetes Cluster</strong>\nOnce Meshery is installed, connect it to your Kubernetes cluster by configuring the necessary authentication and connection details.\n<strong>Step 3: Access MeshMap</strong>\nAfter successfully connecting Meshery to your Kubernetes cluster, you can access MeshMap from the <a href = \"https://playground.meshery.io/\" target=\"_blank\" rel=\"noreferrer\">Meshery</a> user interface. MeshMap visually represents the deployed service mesh, including service endpoints, traffic flows, and workload distribution.\n<strong>Step 4: Visualize the Kubernetes Cluster with MeshMap</strong>\nOnce you have accessed Meshery and connected it to your Kubernetes cluster, follow these steps to visualize the cluster using MeshMap:\n<ol>\n  <li>From the Meshery user interface, navigate to the MeshMap section.</li>\n  <li>Select your connected Kubernetes cluster from the dropdown menu.</li>\n  <li>Click on the \"Generate Map\" button to generate a visual representation of the service mesh components and their interactions within the cluster.</li>\n  <li>Explore the generated MeshMap to gain insights into your Kubernetes cluster's architecture, traffic patterns, and workload distribution.</li>\n</ol>\n\n<h2>Conclusion</h2>\nIn this blog post, we have learned how to bind a Kubernetes Service Account with a ClusterRole to control access and authorization within a cluster. We have also explored how Meshery and its MeshMap feature can be used for visualizing the service mesh components and their interactions within a Kubernetes cluster. By following these steps, you can effectively manage and monitor your Kubernetes cluster's lifecycle using RBAC and visualization tools.\n</BlogWrapper>","frontmatter":{"title":"How To Bind Kubernetes Service Account with ClusterRole","subtitle":"A Comprehensive Guide","date":"June 30th, 2023","author":"Layer5 Team","thumbnail":{"extension":"png","publicURL":"/static/87c3e5e43ab121617b3f31b331d94df7/blog-post.png","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC1ElEQVR42iWSy08bVxTG753B2CBB6zFgg7F5jN8v/AQnJo4hGGIM2DwETYWEKiF10SpShSpVQkoWySJB2UCaVdRF1UZIyQKhNJEise4++zZS/pDw67G7+HTmztz7m++e86ng4f714F4L965oew13u4G7dRf3Wh2rcQf3Sg3rzi2shQpWtYxVKWGVi1ilHFYhQ2ypxnxrnfDKIoFi7lqNbDVR1Vl0dQ5VKaJuFlClDKqQEqXRuSQ6L89SVTqKSoRR0WlUaAI9HcA/mydSKfNVLoUnHkF5l253NzqySRyZBDoeYiCfZjCf6R4y7CDalpqKYmYTmJ0aC2GGp+jpvB/3okc8qK8HGe0AQ+0mkVaTCbGckmovL7J9/wf2frpPsrFMaXOjK0/nB+LMFIdGZAozNIn2ezFHh3AG/ehhC18khIptrZPd2yYhsKQo3rxLfnOdxGqd3MYq45U5ejpuBGBINWJ2d63GhknX67QPDlH9vWhrEF/YRoXFYUIA2Z02ue0WqfUGgepNXIkIPZFp9OQ4amIcLTIEasbE5XQQ5R5gZ/8ez148Jyk9dHoshicCKHujQUyghd0t8gKcaa+R3WgSrS+QlitnV1dwSK864J6oLWA/7rhNaWWB09MnXL5/x/cPnlDb28cWE2pkqYqaieOUQTgycRzJKE754BB3Drlar0hPBTBlrcaGWN7d4fzyL3774xUvf/+TX56ecvTwMScvTkkVcgKUzKlyDuNGHj2bRXeiItPU6RhaBqClZ51BKInIwc9HXHy44uX5a/7++A/nF2+5d/gdja1Nfjw+JppJ838Ob5UwJYdacmjMCbw0gyG5MjIxiUukOwglLsO353l09pw3767499NnTn49wz3qpbe/j/JCjcmQ7PO1V784amVctRs452dxSbBdAnUVZ3AJ1CVtcEkb+qQNZnAM7fPQ+PYbikuLqL5e+oY9DHiHUKbG5x/78h+74l6nS7H/0AAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/87c3e5e43ab121617b3f31b331d94df7/bb8ee/blog-post.png","srcSet":"/static/87c3e5e43ab121617b3f31b331d94df7/0dee1/blog-post.png 750w,\n/static/87c3e5e43ab121617b3f31b331d94df7/8beaa/blog-post.png 1080w,\n/static/87c3e5e43ab121617b3f31b331d94df7/bb8ee/blog-post.png 1200w","sizes":"100vw"},"sources":[{"srcSet":"/static/87c3e5e43ab121617b3f31b331d94df7/a66aa/blog-post.webp 750w,\n/static/87c3e5e43ab121617b3f31b331d94df7/65dd5/blog-post.webp 1080w,\n/static/87c3e5e43ab121617b3f31b331d94df7/edb28/blog-post.webp 1200w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5625}}},"darkthumbnail":{"extension":"png","publicURL":"/static/87c3e5e43ab121617b3f31b331d94df7/blog-post.png","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC1ElEQVR42iWSy08bVxTG753B2CBB6zFgg7F5jN8v/AQnJo4hGGIM2DwETYWEKiF10SpShSpVQkoWySJB2UCaVdRF1UZIyQKhNJEise4++zZS/pDw67G7+HTmztz7m++e86ng4f714F4L965oew13u4G7dRf3Wh2rcQf3Sg3rzi2shQpWtYxVKWGVi1ilHFYhQ2ypxnxrnfDKIoFi7lqNbDVR1Vl0dQ5VKaJuFlClDKqQEqXRuSQ6L89SVTqKSoRR0WlUaAI9HcA/mydSKfNVLoUnHkF5l253NzqySRyZBDoeYiCfZjCf6R4y7CDalpqKYmYTmJ0aC2GGp+jpvB/3okc8qK8HGe0AQ+0mkVaTCbGckmovL7J9/wf2frpPsrFMaXOjK0/nB+LMFIdGZAozNIn2ezFHh3AG/ehhC18khIptrZPd2yYhsKQo3rxLfnOdxGqd3MYq45U5ejpuBGBINWJ2d63GhknX67QPDlH9vWhrEF/YRoXFYUIA2Z02ue0WqfUGgepNXIkIPZFp9OQ4amIcLTIEasbE5XQQ5R5gZ/8ez148Jyk9dHoshicCKHujQUyghd0t8gKcaa+R3WgSrS+QlitnV1dwSK864J6oLWA/7rhNaWWB09MnXL5/x/cPnlDb28cWE2pkqYqaieOUQTgycRzJKE754BB3Drlar0hPBTBlrcaGWN7d4fzyL3774xUvf/+TX56ecvTwMScvTkkVcgKUzKlyDuNGHj2bRXeiItPU6RhaBqClZ51BKInIwc9HXHy44uX5a/7++A/nF2+5d/gdja1Nfjw+JppJ838Ob5UwJYdacmjMCbw0gyG5MjIxiUukOwglLsO353l09pw3767499NnTn49wz3qpbe/j/JCjcmQ7PO1V784amVctRs452dxSbBdAnUVZ3AJ1CVtcEkb+qQNZnAM7fPQ+PYbikuLqL5e+oY9DHiHUKbG5x/78h+74l6nS7H/0AAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/87c3e5e43ab121617b3f31b331d94df7/86bab/blog-post.png","srcSet":"/static/87c3e5e43ab121617b3f31b331d94df7/e1b03/blog-post.png 125w,\n/static/87c3e5e43ab121617b3f31b331d94df7/81b70/blog-post.png 250w,\n/static/87c3e5e43ab121617b3f31b331d94df7/86bab/blog-post.png 500w,\n/static/87c3e5e43ab121617b3f31b331d94df7/8cf60/blog-post.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/87c3e5e43ab121617b3f31b331d94df7/46142/blog-post.webp 125w,\n/static/87c3e5e43ab121617b3f31b331d94df7/81c3e/blog-post.webp 250w,\n/static/87c3e5e43ab121617b3f31b331d94df7/cd07d/blog-post.webp 500w,\n/static/87c3e5e43ab121617b3f31b331d94df7/bf95e/blog-post.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":281}}}},"fields":{"slug":"/blog/meshery/how-to-bind-kubernetes-service-account-with-clusterrole"}},{"id":"4cd22efc-b803-50b8-98ba-ff7c6411fed5","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport MesheryVersion from \"./meshery-version.png\";\n\n<BlogWrapper>\n\n  Meshery is constantly evolving and improving, with new features and bug fixes being added regularly. To stay up to date with the latest Meshery features and updates, you can switch between different release channels.\n  Artifacts of the builds for Meshery and its components are published under two different release channels, so that improved controls may be provided to both  Meshery users and Meshery developers. The two release channels are edge and stable release channels. Relative to stable releases, edge releases occur much more frequently. Edge releases are made with each merge to master, unless that merge to master is for a stable release. Stable releases are made with each\n  merge to master when a GitHub release tag is also present in the workflow.\n<h2> How release channels offer subscription </h2>\n  Release Channels offers a subscription where user can subscribe to a specific  release channel and get notified when a new release is available. This is  useful for users who want to stay up to date with the latest Meshery features, while also also providing flexibility for users who want to stay on a specific version of Meshery.\n  However, this approach can be risky because some updates may introduce bugs or compatibility issues that could break your existing installation. Depending upon your risk aversion and the nature of your deployment environment, having a subscription means that you will automatically receive these updates that you might not be ready incorporate. On the other hand, release channels also offer the ability to pin to a specific release which is a  good thing as it allows users to maintain stability and predictability of their environment by preventing unexpected changes from being introduced into their system. However, doing so cancels out any future subscription-based benefits such as receiving security patches or bug fixes that were added after that version was released.\n\nTherefore, it's important for you to weigh the pros and cons of each option before making decisions on how you want to manage your Meshery deployment. It's recommended you and your organizations have a well-defined upgrade strategy based on testing and validation procedures prior to applying new releases in production environments whether via subscriptions or manual upgrades to ensure that system availability is maintained and risks are minimized.\nTo subscribe to a specific release channel or version using mesheryctl you can use \n<pre><code className=\"language-bash\">mesheryctl system channel set [stable|stable-version|edge|edge-version] </code></pre>\nThis command will update your local Meshery configuration to use the selected channel for future updates. To set the channel to a specific version, replace Version with the desired version number. Example: <code className=\"language-bash\">mesheryctl system channel set stable</code> or <code className=\"language-bash\">mesheryctl system channel set stable-v0.5.56</code>\n<h2> Switching between Release Channels</h2>\nThere are two ways to switch between Meshery release channels: using mesheryctl or by editing your meshconfig file. In this blog post, we'll cover both methods.\n<h3>What is Meshconfig?</h3>\n  Meshconfig is a configuration file that is used to configure Meshery. It is typically located in the <code>~/.meshery/config.yaml</code> directory. It contains information about the current release channel, the version of Meshery that is installed, and other configuration options that are specific to your Meshery installation. \n  Meshconfig is automatically generated when you run Meshery for the first time. It is also automatically updated when you update Meshery\n<ol>\n<h3>Switching between Meshery release channels using meshconfig file.</h3>\nOpen your terminal and confirm that you have mesheryctl installed by running  <code>mesheryctl version</code>. If you don't have mesheryctl installed, you can install it by following the instructions in the  <a href=\"https://docs.meshery.io/installation/mesheryctl\">Meshery documentation</a>.\n<li>Create new Meshery config.yaml file <pre><code className=\"language=bash\">mesheryctl system context create [context-name]</code></pre></li>\nExample: <br/> <code className=\"language-bash\">mesheryctl system context create new-context --components meshery-istio meshery-osm meshery-linkerd --platform docker --url http://localhost:9081 --set --yes </code>\n<li> To view the newly created meshery context use <pre><code className=\"language-bash\">mesheryctl system context view [context-name]</code></pre></li>\n<li>After making these changes, you can switch between different context by using <pre><code className=\"language-bash\">mesheryctl system context switch</code></pre></li>\n</ol>\n\n<h3>Switching between Meshery release channels using mesheryctl.</h3>\nmesheryctl is a command-line tool for managing Meshery. You can use it to switch between different release channels. Here's how:\n<ul>\n  <li>Run the following command to see the current configuration for Meshery: <pre><code className=\"language-bash\">mesheryctl system context view</code></pre><img src={MesheryVersion} className=\"image-center\" style={{ width: \"50%\" }} />This will show you the current release channel (<b>stable</b> or <b>edge</b>), along with the version number and other information.</li>\n  <li>Run the following command to switch to a different release channel:<pre><code className=\"language-bash\">mesheryctl system channel switch</code></pre>This command will update your meshconfig file to switch release channel and version of context in focus. To switch the channel to a specific version, replace <b>Version</b> with the desired version number.</li>\n  <li>To confirm that the channel has been changed, run the following command again: <pre><code className=\"language-bash\">mesheryctl system channel view</code></pre></li>\n</ul>\n\n<h2>Conclusion </h2>\n\n  Switching between Meshery release channels is a simple and straightforward process. You can do it using mesheryctl or by switching between your meshconfig file. Whether you want stable updates or bleeding-edge features, Meshery has a release channel that suits your needs. Just remember to carefully consider your use case and needs before making any changes to ensure that you have the best Meshery experience.\n</BlogWrapper>\n","frontmatter":{"title":"Changing Meshery Release Channels","subtitle":"Change Meshery Release Channels using mesheryctl or using your meshconfig file.","date":"June 16th, 2023","author":"Karan Thakur","thumbnail":{"extension":"png","publicURL":"/static/60fe9ee92d711b8b6d591e00535d18ef/change-meshery-release-channels.png","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACI0lEQVR42kWSS28TMRSFTSqqqilNxh5nXvZ4HhnPZJp5NJlJQiktFApqKAQFpWRbJKQu2AD/gCVSkWDFom0KXYBA4qHyWoD4aziKaKSjI8vy53vvsUGU8sGw1+tvDe73VtdywrDlKsxRTCG7MhGrqpZRwv3r4O8H8Oc9+P0OfDsGpyPgeHrSCMLIFRJrjUg6hTqVCJPHmDWWostqpVzsb80+3Zt7tDv3+OG5j6/B9zfAYIjX2MVLjc7KcquTrF1tX77SEr4UVw0mW0yJ6zaziG3bLqUUQjxfRGWpcLQPfp4AamEvMLvb13aGd7d7N7u3Nm7f2RRT1OrOuLiFswhlqRtHYVCrMUY1VVVMOnP8YgyL3gTPa2YYOdwnXlrlkROE1mRaynArRWnd5B43TZMQalJKHHtmJOC3YHKIUKgGFK83i0920WaHKgvjwJyKQStpmmRZ5nlckiSEEJQkqCqF0VllwROo57XS3hANbujt0KRQbDIBExzHSZ7nhBAIoYyxDBHS1CnMXNW2sNH04YN72mpCItsSIbsas2SDKUkzz/Kc+76m60jAsox0bQp7ARWvnWVhlnjNlDezMG4E3KfUN6SdblY38niJ2458YRGXynhhUUZyYbQ/DUy44xkuN2xPdzmxPJ3heTTszr56ZrY9ut5RV9ql5ajcjMvCW43CyUvw439gkyvOZDKZ+uT84XPw6wR8OgSfD8CXA/D1aCrxvU5H/wCqZH2AqKZNzAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/60fe9ee92d711b8b6d591e00535d18ef/afa5c/change-meshery-release-channels.png","srcSet":"/static/60fe9ee92d711b8b6d591e00535d18ef/0dee1/change-meshery-release-channels.png 750w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/8beaa/change-meshery-release-channels.png 1080w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/d079a/change-meshery-release-channels.png 1366w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/afa5c/change-meshery-release-channels.png 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/60fe9ee92d711b8b6d591e00535d18ef/a66aa/change-meshery-release-channels.webp 750w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/65dd5/change-meshery-release-channels.webp 1080w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/4fad6/change-meshery-release-channels.webp 1366w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/c512e/change-meshery-release-channels.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5625}}},"darkthumbnail":{"extension":"png","publicURL":"/static/60fe9ee92d711b8b6d591e00535d18ef/change-meshery-release-channels.png","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACI0lEQVR42kWSS28TMRSFTSqqqilNxh5nXvZ4HhnPZJp5NJlJQiktFApqKAQFpWRbJKQu2AD/gCVSkWDFom0KXYBA4qHyWoD4aziKaKSjI8vy53vvsUGU8sGw1+tvDe73VtdywrDlKsxRTCG7MhGrqpZRwv3r4O8H8Oc9+P0OfDsGpyPgeHrSCMLIFRJrjUg6hTqVCJPHmDWWostqpVzsb80+3Zt7tDv3+OG5j6/B9zfAYIjX2MVLjc7KcquTrF1tX77SEr4UVw0mW0yJ6zaziG3bLqUUQjxfRGWpcLQPfp4AamEvMLvb13aGd7d7N7u3Nm7f2RRT1OrOuLiFswhlqRtHYVCrMUY1VVVMOnP8YgyL3gTPa2YYOdwnXlrlkROE1mRaynArRWnd5B43TZMQalJKHHtmJOC3YHKIUKgGFK83i0920WaHKgvjwJyKQStpmmRZ5nlckiSEEJQkqCqF0VllwROo57XS3hANbujt0KRQbDIBExzHSZ7nhBAIoYyxDBHS1CnMXNW2sNH04YN72mpCItsSIbsas2SDKUkzz/Kc+76m60jAsox0bQp7ARWvnWVhlnjNlDezMG4E3KfUN6SdblY38niJ2458YRGXynhhUUZyYbQ/DUy44xkuN2xPdzmxPJ3heTTszr56ZrY9ut5RV9ql5ajcjMvCW43CyUvw439gkyvOZDKZ+uT84XPw6wR8OgSfD8CXA/D1aCrxvU5H/wCqZH2AqKZNzAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/60fe9ee92d711b8b6d591e00535d18ef/86bab/change-meshery-release-channels.png","srcSet":"/static/60fe9ee92d711b8b6d591e00535d18ef/e1b03/change-meshery-release-channels.png 125w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/81b70/change-meshery-release-channels.png 250w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/86bab/change-meshery-release-channels.png 500w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/8cf60/change-meshery-release-channels.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/60fe9ee92d711b8b6d591e00535d18ef/46142/change-meshery-release-channels.webp 125w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/81c3e/change-meshery-release-channels.webp 250w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/cd07d/change-meshery-release-channels.webp 500w,\n/static/60fe9ee92d711b8b6d591e00535d18ef/bf95e/change-meshery-release-channels.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":281}}}},"fields":{"slug":"/blog/meshery/changing-meshery-release-channels"}},{"id":"fbda537a-afd2-57b2-b44d-784c1df43d3c","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport Switcher from \"./context-switcher.webp\";\nimport Deploy from \"./deploy-modal.webp\";\nimport Cluster2 from \"./meshmap-cluster2.webp\";\nimport Cluster1 from \"./meshmap-cluster1.webp\";\nimport Settings from \"./settings.webp\";\nimport Cluster from \"./cluster-mgmt.webp\";\nimport Flush from \"./flush-meshsync.webp\";\nimport CoreArch from \"./meshery-core-architecture.webp\";\nimport { Link } from \"gatsby\";\n\n<BlogWrapper>\n\n<div className=\"intro\">\n\n      From multi-mesh to now multi-cluster, <Link to=\"/meshery\">Meshery</Link> is\n    continuously expanding its capability to give developers, operators, and\n    security engineers more control over their infrastructure. In this post,\n    we'll take a look behind the scenes at how each component in Meshery's\n    architecture plays a role in the management of many Kubernetes clusters.\n\n</div>\n\n## Philosophy behind Meshery's multi-cluster management approach\n\nWhile designing Meshery for the world of many clouds, and many Kubernetes clusters, much care has been taken to ensure that Meshery is an <a href=\"https://docs.meshery.io/extensibility\">extensible management platform</a>, ready for handling new types of infrastructure and new use cases rapidly through its plugin model. Under the hood, <a href=\"https://docs.meshery.io\">Meshery Server</a> acts as a delegator of operations by figuring out which Meshery Adapter registered its capability against the given operation. The operation is then sent to that given component (like one of Mesheryâ€™s adapters,e.g. Istio adapter) via a gRPC call. <img src={CoreArch} alt=\"deploy modal\"  className=\"image-right\"/> When the operation involves a Kubernetes cluster(s), the kubeconfig(s) is sent as a parameter to the RPCs. It is then the job of the handling adapter to respect that and perform the operation across the passed clusters from kubeconfigs as needed. The operations not requiring a kubeconfig are managed through the same RPC, with the only difference being that the handling component would ignore the `kubeconfigs` field altogether making the system work not just for Kubernetes, but for other cloud native use cases. This approach of reusing the same RPC for different types of requests is pretty common and sometimes debatable with the other approach of being strict with the RPCs. This is what makes Meshery completely pluggable and extensible.\n\n## Using multi cluster with Meshery\n\nFrom a client's perspective, there are two uses of the multi context feature in general. While deploying a <Link to=\"/kanvas\">Kanvas</Link> design or performing any other operation on their cluster(s), selecting any number of Kubernetes contexts will allow them to uniformly and parallely perform the operation across the clusters. And while visualizing the state of their cluster(s), the same context switcher will allow them to filter across the clusters whose view they want to see.\n\nAll cluster specific operations are now applied over a number of clusters uniformly. So if you have 10 clusters to manage and 8 of those start with the exact same set of pods, deployments, services, etc then <Link to=\"/meshery\">Meshery</Link> can help you to apply these operations quickly and easily.\n\nIt is as simple as selecting the specific cluster(s) from the Kubernetes context switcher in the navbar, and then applying whatever operation you wanted to, whether that be deploying a sample app, a Prometheus daemonset, or a <Link to=\"/kanvas\">Kanvas</Link> design.\n\n\nJust before applying the operation, you will be prompted with a confirmation modal which will provide the information about which cluster(s) that operation will be performed against. As the User interface improves, this same modal will also convey more useful information about the operation they are going to perform.\n\n\n<br />\n\n### Using Kanvas Operator Mode\n\nYou can switch between views of your cluster in visualizer mode while using <a href=\"https://kanvas.new\">Kanvas</a>.\n\n\n\n### Managing Meshery on multiple clusters\n\nUsers can perform cluster related operations from the settings page like adding more clusters, removing data from existing clusters and removing existing clusters.\n\n<img src={Settings} alt=\"Settings page\" className=\"slides-right\"/>\n\nMeshery also deploys Meshery operator across the cluster itâ€™s about to manage. This operator manages the lifecycle of a Meshery broker and MeshSync. MeshSync pumps the blood into Mesheryâ€™s core, in other words, it is responsible for watching all different types of resources by establishing a watch stream over each of them. MeshSync then pumps that data into the NATS server, of which Meshery server itself is a client. From there, Meshery server gets all the relevant data related to activities in the cluster.\n\nBy default, <Link to=\"/meshery\">Meshery</Link> wants to be as much aware about your infrastructure as possible to provide value so it deploys its operator across each detected cluster. But you can fine tune this configuration by going over each one of them from the table as shown.\n\n<img\n  src={Cluster}\n  alt=\"Kubernetes multi-cluster management with Meshery\"\n  className=\"image-center-shadow\"/>\n\nIf you disconnect your cluster and do not want to persist the data from that cluster then you can perform a fine-grained deletion by deleting all MeshSync data (which are the Kubernetes objects) for that specific cluster.\n\n<img src={Flush} alt=\"flushing MeshSync data\" className=\"image-center-shadow\"/>\n## Future of multi-cluster\n\nMeshery as an extension point to your infrastructure provides out-of-the-box value by adding components which can be Kubernetes specific, service mesh specific or custom components to add new functionality. We can now add multi-cluster specific components to provide more abstraction. This model can be used along with Mesheryâ€™s multi-mesh capabilities to give an overall multi-mesh multi-cluster experience to the user. For instance, your Istio service mesh spanning across multiple clusters can be abstracted and managed by Meshery using custom components such as VirtualGateway and VirtualDestinationRules. In this case, Mesheryâ€™s Istio adapter will handle the logic of converting a VirtualGateway into gateways across the clusters. This abstraction provides high value by powering the service mesh to span across the clusters while the Ops team can configure the mesh with minimal effort.\n\nJust like the example above, many such Meshery extension points are in Meshery to add logic into and add useful functionality. And as more of such extension points are added, Meshery will continue to give more and more power to your cloud native infrastructure.\n\n</BlogWrapper>\n","frontmatter":{"title":"Multi-Cluster Kubernetes Management with Meshery","subtitle":"Wrangling your services one cluster at-a-time","date":"July 28th, 2022","author":"Ashish Tiwari","thumbnail":{"extension":"webp","publicURL":"/static/93e4b9e86c2d9eabe418ca1f023b3e26/multi-cluster-kubernetes-management-with-meshery.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRoAAAABXRUJQVlA4IHQAAACQAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJZwDE2CF54D5t+bwgAP68SM3n4NvbowqxZAxrpC/QYjXpmca9fnDRt2vaA4crmoLs6No+L37Zc43rqKBUXdMCecvSw2drXRb5/RfsD7tY1aZ37HN/ekX7tRAAAA=="},"images":{"fallback":{"src":"/static/93e4b9e86c2d9eabe418ca1f023b3e26/c512e/multi-cluster-kubernetes-management-with-meshery.webp","srcSet":"/static/93e4b9e86c2d9eabe418ca1f023b3e26/a66aa/multi-cluster-kubernetes-management-with-meshery.webp 750w,\n/static/93e4b9e86c2d9eabe418ca1f023b3e26/65dd5/multi-cluster-kubernetes-management-with-meshery.webp 1080w,\n/static/93e4b9e86c2d9eabe418ca1f023b3e26/4fad6/multi-cluster-kubernetes-management-with-meshery.webp 1366w,\n/static/93e4b9e86c2d9eabe418ca1f023b3e26/c512e/multi-cluster-kubernetes-management-with-meshery.webp 1920w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5625}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/93e4b9e86c2d9eabe418ca1f023b3e26/multi-cluster-kubernetes-management-with-meshery.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRoAAAABXRUJQVlA4IHQAAACQAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJZwDE2CF54D5t+bwgAP68SM3n4NvbowqxZAxrpC/QYjXpmca9fnDRt2vaA4crmoLs6No+L37Zc43rqKBUXdMCecvSw2drXRb5/RfsD7tY1aZ37HN/ekX7tRAAAA=="},"images":{"fallback":{"src":"/static/93e4b9e86c2d9eabe418ca1f023b3e26/cd07d/multi-cluster-kubernetes-management-with-meshery.webp","srcSet":"/static/93e4b9e86c2d9eabe418ca1f023b3e26/46142/multi-cluster-kubernetes-management-with-meshery.webp 125w,\n/static/93e4b9e86c2d9eabe418ca1f023b3e26/81c3e/multi-cluster-kubernetes-management-with-meshery.webp 250w,\n/static/93e4b9e86c2d9eabe418ca1f023b3e26/cd07d/multi-cluster-kubernetes-management-with-meshery.webp 500w,\n/static/93e4b9e86c2d9eabe418ca1f023b3e26/bf95e/multi-cluster-kubernetes-management-with-meshery.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":281}}}},"fields":{"slug":"/blog/meshery/multi-cluster-kubernetes-management-with-meshery"}},{"id":"0bf099ea-9608-5c18-9882-81c42e07ea75","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport mesheryui from \"./mesheryui.webp\"; \n\n<BlogWrapper>\n\n<div className=\"intro\">\n<a href=\"https://meshery.io/\">Meshery</a>'s goal is to make the operation of cloud native infrastructure and the service mesh layer of cloud simplified. Originally created by Layer5, Meshery is an open source project with hundreds of contributors world-wide and is actively maintained by engineers from Red Hat, VMware, Intel, Layer5 and others.\n</div>\n<h2>Setup and run Meshery on AKS</h2>\nThe following instructions expects you to have an active Azure subscription, and Azure CLI installed on your system.\n<h3> Spin up the AKS Cluster</h3>\nCreate the resource group (a logical group where all our resources will be deployed). The following command creates  a resource group named MesheryGroup in <code>southindia</code> location.\n<pre><code className=\"language-bash\">\naz group create --name MesheryGroup --location southindia\n</code></pre>\n\nCreate AKS cluster using <code>az aks create</code>. The following command creates aks cluster with a single node.\n<pre><code className=\"language-bash\">\naz aks create --resource-group MesheryGroup --name MesheryAKS --node-count 1 --generate-ssh-keys\n</code></pre>\nAfter a few minutes, the command completes and returns a JSON formatted information about the cluster.\nYou can connect with your cluster by using <code>az aks get-credentials</code> ,  which basically downloads credentials and configure the Kubernetes CLI.\n<pre><code>\naz aks get-credentials --resource-group MesheryGroup --name MesheryAKS\n</code></pre>\nVerify the connection to your cluster using the <code>kubectl get command</code>.\n<pre><code>\n$kubectl get nodes\n</code></pre>\n<h3>Install Meshery into your AKS cluster</h3>\n\n```\nhelm repo add meshery https://meshery.io/charts/\n\nhelm install meshery meshery/meshery --namespace meshery --create-namespace\n\n```\nMeshery server supports customizing authentication flow callback URL, which can be configured in the following way.\n<pre><code>\nhelm install meshery meshery/meshery --namespace meshery --set env.MESHERY_SERVER_CALLBACK_URL=https://custom-host --create-namespace\n</code></pre>\nPort forward to Meshery UI\n```\nexport POD_NAME=$(kubectl get pods --namespace meshery -l \"app.kubernetes.io/name=meshery,app.kubernetes.io/instance=meshery\" -o jsonpath=\"{.items[0].metadata.name}\")\n\n$ kubectl --namespace meshery port-forward $POD_NAME 9081:8080\n\n```\nMeshery should now be running in your AKS cluster and the Meshery UI should be accessible at the specified endpoint youâ€™ve exposed to. Navigate to the meshery service endpoint to log into Meshery.\n<div><img src={mesheryui} className=\"image-center\" alt=\"Meshery UI Dashboard\" /></div>\n\nFrom here, your Meshery deployment on AKS is ready to use. In order to login to Meshery, authenticate with your chosen provider from the list.\nThere are different ways to configure a Meshery on AKS. Join the <a href=\"https://layer5.io/community\">community</a> and share your deploymentâ€™s configuration on the <a href=\"https://discuss.layer5.io/\"> discussion forum </a>today!\n</BlogWrapper>\n","frontmatter":{"title":"How to deploy Meshery on AKS","subtitle":null,"date":"July 21st, 2022","author":"Srinivas Karnati","thumbnail":{"extension":"webp","publicURL":"/static/3fe6493b7ebec3694bc03967df3a3a83/Meshery-on-AKS.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRmYAAABXRUJQVlA4IFoAAADQAwCdASoUAAoAPtFipk0oJiOiMAgBABoJaACw7GYVobqX7FMxDIAA/qX3az11ecS2G7Ywek1haVMFjWlflvPlov5ZOXa13PEkNYdR0wgoGPwU0M3fO53QAAA="},"images":{"fallback":{"src":"/static/3fe6493b7ebec3694bc03967df3a3a83/f9756/Meshery-on-AKS.webp","srcSet":"/static/3fe6493b7ebec3694bc03967df3a3a83/ee7ce/Meshery-on-AKS.webp 750w,\n/static/3fe6493b7ebec3694bc03967df3a3a83/819dc/Meshery-on-AKS.webp 1080w,\n/static/3fe6493b7ebec3694bc03967df3a3a83/f9756/Meshery-on-AKS.webp 1200w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/3fe6493b7ebec3694bc03967df3a3a83/Meshery-on-AKS.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRmYAAABXRUJQVlA4IFoAAADQAwCdASoUAAoAPtFipk0oJiOiMAgBABoJaACw7GYVobqX7FMxDIAA/qX3az11ecS2G7Ywek1haVMFjWlflvPlov5ZOXa13PEkNYdR0wgoGPwU0M3fO53QAAA="},"images":{"fallback":{"src":"/static/3fe6493b7ebec3694bc03967df3a3a83/cd5ef/Meshery-on-AKS.webp","srcSet":"/static/3fe6493b7ebec3694bc03967df3a3a83/f6072/Meshery-on-AKS.webp 125w,\n/static/3fe6493b7ebec3694bc03967df3a3a83/cb4bd/Meshery-on-AKS.webp 250w,\n/static/3fe6493b7ebec3694bc03967df3a3a83/cd5ef/Meshery-on-AKS.webp 500w,\n/static/3fe6493b7ebec3694bc03967df3a3a83/0f033/Meshery-on-AKS.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":250}}}},"fields":{"slug":"/blog/meshery/how-to-deploy-meshery-on-aks"}},{"id":"de0c7552-7a04-5f35-8a06-4b6842d35504","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\n\n<BlogWrapper>\n\nHola folks,\nAs a contributor, each of us is always striving hard in the ocean to open more and more pull-requests, but being a contributor just doesn't mean only raising PRs, it also means reviewing other PRs, pointing out mistakes, helping others in improving the **code-quality/code-reusability/code-readability**, helping in finding missing edge-cases that haven't been tackled yet, giving your opinions, writing LGTM, CITY helps nothing but just improving the confidence and engagement of the PR author.\nSo put on your **Quality Tester** hats because here I'll talk about how to test the PRs with the label `component/mesheryctl` i.e. pull-requests related to `mesheryctl`.\n\nOkay before we start, I'll like to tell you about <a href=\"https://github.com/cli/cli\">GitHub CLI</a>, it helps you checkout PRs very easily in your local system.\n<ol>\n    <li>The very first step is to **review the PR**, suggest changes if you think of any, ask queries, help the author to improve the code quality/readability/reusability, ask questions because asking helps you learn asking more better questions next time.</li>\n    <li>PR authors either attach a video showcasing expected behavior or add written instructions about their fix under **User Acceptance Behavior**.</li>\n    <li>Now it's the time to **checkout PR** in your local system, we can check out any PR like this:<pre><code className=\"language-bash\">gh pr checkout https://github.com/meshery/meshery/pull/4823</code></pre></li>\n    <li>You can check if you're into the same branch as the PR author with:<pre><code className=\"language-bash\">git branch</code></pre></li>\n    <li>Well, if we're testing a PR related to mesheryctl, we need to **build the binary** from the same branch. Change your directory to the `mesheryctl` folder and run:<pre><code className=\"language-bash\">make</code></pre>This will create a **mesheryctl binary** according to your OS in the same directory.</li>\n    <li>Now it's time to **test out this newly built binary** according to what's been tackled in the PR and related issues. For e.g. `system start` has some new functionality, make sure you followed the pull-request/linked-issue instruction for env setup, as sometimes fix/features are tackling an issue with a specific type of environment.<pre><code className=\"language-bash\">./mesheryctl system start</code></pre>the `./` helps us in using the newly built cli-binary present in the current directory which we built in 5th step.</li>\n</ol>\n<ol start=\"7\">\n    <li>Make sure we have a similar experience as mentioned in the Video or the instructions added to the PR. But wait, is it okay to give green flags to the PR? not yet tbh. We as a tester should **turn a little evil** and think of the relevant situations/environments which might not have been tackled but should be (basically we're trying to **break the new feature/fix**).</li>\n    <li>After spending a good amount of time testing the new behaviors, old standard behaviors, new test cases, few edge cases. We can provide new insights to the PR author about the behavior in your system, depending on our experience we can ask the PR author to address our new queries, or we can appreciate the work, or give green flags to the PR.</li>\n</ol>\nWow, that was a ton of work there. Well being a **Tester** is tough but very important before we merge pull requests. Every PR should be marked green with **end-to-end testing** before merging, we as a project are using **GH Workflows** to perform standard golang-testing but manual end-to-end testing completely removes margins of error.\n</BlogWrapper>","frontmatter":{"title":"Validating Meshery CLI Functionality","subtitle":"An introduction to testing mesheryctl","date":"June 10th, 2022","author":"Piyush Singariya","thumbnail":{"extension":"webp","publicURL":"/static/9156c22b67aedb4c9c71f4951b06f17f/thumbnail.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAADwAgCdASoUAAcAPtFUo0uoJKMhsAgBABoJZwCdADBsAAD+8CVGzfndbE6d1gAA"},"images":{"fallback":{"src":"/static/9156c22b67aedb4c9c71f4951b06f17f/16531/thumbnail.webp","srcSet":"/static/9156c22b67aedb4c9c71f4951b06f17f/a4fab/thumbnail.webp 750w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/16baf/thumbnail.webp 1080w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/5eb4b/thumbnail.webp 1366w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/16531/thumbnail.webp 1895w","sizes":"100vw"},"sources":[]},"width":1,"height":0.36358839050131925}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/9156c22b67aedb4c9c71f4951b06f17f/thumbnail.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAADwAgCdASoUAAcAPtFUo0uoJKMhsAgBABoJZwCdADBsAAD+8CVGzfndbE6d1gAA"},"images":{"fallback":{"src":"/static/9156c22b67aedb4c9c71f4951b06f17f/abe74/thumbnail.webp","srcSet":"/static/9156c22b67aedb4c9c71f4951b06f17f/83606/thumbnail.webp 125w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/ce4a2/thumbnail.webp 250w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/abe74/thumbnail.webp 500w,\n/static/9156c22b67aedb4c9c71f4951b06f17f/1165c/thumbnail.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":182}}}},"fields":{"slug":"/blog/meshery/validating-meshery-cli-functionality"}},{"id":"d3755e16-1694-5614-8d5f-5fe6f590fc95","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport Blockquote from \"../../../../reusecore/Blockquote\";\n\nimport oldDesign from \"./initial-design.webp\";\nimport newDesign from \"./mesheryctl-docs.webp\";\n\n<BlogWrapper>\n\n<div className=\"intro\">\nDocumentation plays a major role in any project. Even if the project is small or too big, the creator or the team behind the project needs to curate the documentation very well such that it'll be useful for new end users to refer and learn to use the project, troubleshoot the problems occurred and lot more. Thus, we, Layer5 have curated the documentation for Meshery to meet such purposes. Not to mention, <code>mesheryctl</code>, the CLI client of Meshery needs a curated documentation as well. This blog describes about the evolution of <code>mesheryctl</code> command reference page.\n</div>\n\n<h3>Initial Command Reference Design</h3>\nThe initial design of <code>mesheryctl</code> command reference page is all made using pure markdown and the functionality is handled using Jekyll, the main framework used for Meshery Docs. This handled great at initial stage but had many limitations, such as:\n    <ul>\n        <li>Updation of YAML for data is often required</li>\n        <li>Design was obselete at initial stage</li>\n        <li>No separate pages for each command and subcommand</li>\n    </ul>\n    Thus, the idea for redesigning the <code>mesheryctl</code> reference page was desperately needed.\n    <a href=\"https://docs.meshery.io\" alt=\"Meshery Documentation\" target=\"_parent\">\n    <img src = {oldDesign} className=\"image-center-shadow\" alt=\"Initial design of mesheryctl command reference\" /></a>\n<h3>Updated Command Reference Design</h3>\nTo tackle the shortcomings of the previous design, I was tasked to redesign the <code>mesheryctl</code> command reference page entirely. This was a big task at first glance to me, as I was a new contributor back then. Eventually after manipulating the reference section with help of great folks, I was able to pull off the task and the design was updated.\n    <a href=\"https://docs.meshery.io\" alt=\"Meshery Documentation\">\n<img src={newDesign} className=\"image-center-shadow\" alt=\"Meshery CLI command reference\" /></a>\n\nThe redesign work was done with help of HTML in markdown and with optimization in YAML code. A sample is given below.\n\n```shell\n    <!-- Copy this template to create individual doc pages for each mesheryctl commands -->\n\n    <!-- Name of the command -->\n    # mesheryctl mesh\n\n    <!-- Description of the command. Preferably a paragraph -->\n    ## Description\n\n    {% assign name = site.data.mesheryctlcommands.cmds[page.command] %}\n    {{ name.description }}\n\n    <!-- Basic usage of the command -->\n    <pre className=\"codeblock-pre\">\n    <div className=\"codeblock\">\n    mesheryctl mesh [flags] \n    </div>\n    </pre>\n    ...........\n```\n\n<h3>Adding auto generation feature in reference</h3>\n\nAs time passed, we realized that the command reference missed something for a while, though the design has been changed. Then, we thought the idea of automating the generation of docs such that developers don't need to change the code in docs section while working towards <code>mesheryctl</code>. That's where we got to know that Cobra library (the library for CLI apps made using golang) has a feature to make doc pages automatically. So we decided to incorporate that feature into <code>mesheryctl</code> docs page as well! After making several changes and a PR, I was finally able to introduce the feature in the docs site!\n\n```\nvar startCmd = &cobra.Command {\n\tUse:   \"start\",\n\tShort: \"Start Meshery\",\n\tLong:  `Start Meshery and each of its service mesh components.`,\n\tArgs:  cobra.NoArgs,\n\tExample: `\n// Start meshery\nmesheryctl system start\n// To create a new context for in-cluster Kubernetes deployments and set the new context as your current-context\nmesheryctl system context create k8s -p kubernetes -s\n// (optional) skip checking for new updates available in Meshery.\nmesheryctl system start --skip-update\n// Reset Meshery's configuration file to default settings.\nmesheryctl system start --reset\n// Silently create Meshery's configuration file with default settings\nmesheryctl system start --yes\n.....\n}\n\t`,\n```\n\nUsing this information provided above in each golang file, the markdown page is generated using Cobra CLI library and thus reducing the workload on the developer by automating via <a href=\"https://github.com/meshery/meshery/blob/master/.github/workflows/mesheryctl-ci.yml#L73\">GitHub Actions</a>.\n<br />\nThis is so far on how the <code>mesheryctl</code> command reference is evolved for now. And I hope that it'll continue to evolve in the field of documentation to serve the users to use Meshery in best way possible.\n</BlogWrapper>\n","frontmatter":{"title":"Evolution of the Meshery CLI Command Reference","subtitle":null,"date":"June 9th, 2022","author":"Aadhitya Amarendiran","thumbnail":{"extension":"webp","publicURL":"/static/8b8429808b6e7381fa812bf1f5d29572/mesheryctl.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRnwAAABXRUJQVlA4IHAAAABwBACdASoUAA0APtFWpEuoJKOhsAgBABoJbACdMoGvtgJwx880HleA8ofTgAD+2VgctvGN2cFdfAJj4YJ0Ha8AiiMSiWh82G/yk9ZshKIR54QST0HBPk98AjqzxGHfuVZiMjvT9XDm39S3tEJ+oAAA"},"images":{"fallback":{"src":"/static/8b8429808b6e7381fa812bf1f5d29572/1c0a1/mesheryctl.webp","srcSet":"/static/8b8429808b6e7381fa812bf1f5d29572/f06bf/mesheryctl.webp 750w,\n/static/8b8429808b6e7381fa812bf1f5d29572/8c7d4/mesheryctl.webp 1080w,\n/static/8b8429808b6e7381fa812bf1f5d29572/1c0a1/mesheryctl.webp 1200w","sizes":"100vw"},"sources":[]},"width":1,"height":0.6316666666666667}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/8b8429808b6e7381fa812bf1f5d29572/mesheryctl.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRnwAAABXRUJQVlA4IHAAAABwBACdASoUAA0APtFWpEuoJKOhsAgBABoJbACdMoGvtgJwx880HleA8ofTgAD+2VgctvGN2cFdfAJj4YJ0Ha8AiiMSiWh82G/yk9ZshKIR54QST0HBPk98AjqzxGHfuVZiMjvT9XDm39S3tEJ+oAAA"},"images":{"fallback":{"src":"/static/8b8429808b6e7381fa812bf1f5d29572/704ce/mesheryctl.webp","srcSet":"/static/8b8429808b6e7381fa812bf1f5d29572/5a879/mesheryctl.webp 125w,\n/static/8b8429808b6e7381fa812bf1f5d29572/6d26b/mesheryctl.webp 250w,\n/static/8b8429808b6e7381fa812bf1f5d29572/704ce/mesheryctl.webp 500w,\n/static/8b8429808b6e7381fa812bf1f5d29572/5c637/mesheryctl.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":316}}}},"fields":{"slug":"/blog/meshery/evolution-of-the-meshery-cli-command-reference"}},{"id":"5d6e85c1-a958-51c5-a20e-1308e5fd0237","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport Blockquote from \"../../../../reusecore/Blockquote\";\n\nimport UnitTest from \"./unit-test.webp\";\nimport IntegrationTest from \"./integration-test.webp\";\nimport TreeGraph from \"./tree-graph.webp\";\n\n<BlogWrapper>\n\n<div className=\"intro \">\nDelivering a high quality user experience is our pinnacle goal in the design of Meshery's CLI: <code>mesheryctl</code>. Delivering a high quality user experience means testing both qualitatively and quantatively. As a concept, quality - whether you're talking about software or anything else - can be directly measured by consistency. A quality user experience is consistent and consistency of <code>mesheryctl</code> is reinforced by its many unit tests.\n</div>\n\n<code>mesheryctl</code> is written in Golang. In the Meshery project, we use CodeCov to calculate the code coverage across <code>mesheryctl</code>'s line of code. And there are plenty of lines of code. Achieving high percentages of code coverage in Meshery's CLI with grows in criticality as we bring more features into <code>mesheryctl</code> as a robust and sophisticated command line client of Meshery. Unit and integration tests bolster and roll up into broader end-to-end, functional testing performed across Meshery and the rest of its components.\nHigh levels of code coverage makes it easier for each project contributor to be confident that their code changes arenâ€™t breaking any preexisting <code>mesheryctl</code> commands, side-swiping their functionality unknowingly, and consequently, unwittingly lowering the quality of Meshery's overall user experience.\n<h3> mesheryctl lines of code</h3>\n\n\n```yaml\n\n    270 text files.\n    106 unique files.\n    166 files ignored.\n\n    cloc v 1.92  T=0.15 s (692.3 files/s, 110063.3 lines/s)\n    ------------------------------------------------------------------\n    Language       files          blank        comment           code\n    ------------------------------------------------------------------\n    Go                88           2128           1330          13045\n    YAML              12              0              0            215\n    JSON               4              0              0             42\n    make               1             10              2             31\n    Markdown           1             23              0             27\n    ------------------------------------------------------------------\n    SUM:             106           2161           1332          13360\n    ------------------------------------------------------------------\n```\n\nUnit Tests can be written in two ways:\n<ol>\n    <li>\n        Test <code>mesheryctl</code> subcommand\n        <ol>\n            <li>Mock Meshery(backend) response if needed</li>\n            <li>Grab console output</li>\n            <li>Store standard/verified mesheryctl output in a golden file(a text file)</li>\n            <li>Match the stored/expected output with what we grab from the console</li>\n            <li>Cover as many scenarios as possible, test the situations where errors must be thrown</li>\n            <li>This is a standard format, changes can be made accordingly</li>\n        </ol>\n    </li>\n    <li>\n        Test <code>mesheryctl</code> functions\n        <ol>\n            <li>This is the standard testing you may have come across in every project</li>\n            <li>You write one test dedicated to one function covering all possible test-cases, matching expected outputs</li>\n        </ol>\n    </li>\n</ol>\n\n<h3>Example tree graph</h3>\nThis example of a tree graph (from <a href=\"https://github.com/meshery/meshery/pull/4823\">meshery/meshery/pull/4823</a>) shows the impact given changes make on the level of code coverage.\n<img src={TreeGraph} />\n\n<h3>Integration Tests</h3>\n\nIntegrations tests come into view when you cannot mock something easily and when a given behavior is cross-functional / cross-component. Integration tests put more, but not all of the focus validating system behavior and that the system completes all the necessary actions. Take <code>mesheryctl system start</code> for example. This command deploys Meshery, its adapters, and Kubernetes Operator; it starts Meshery. So, you run the command to start Meshery in a GitHub workflow and after running the <code>mesheryctl</code> subcommand through the tests and make sure that Meshery actually started. And if the workflow successfully runs the test, then boom!, you aced your integration writing test... errr... test writing.\nThe integration test writing exam can initially be challenging, but... thatâ€™s the fun in it. :) Running tests and making sure a command that is otherwise hard to verify, hard to test, and making it automatic through GH workflows.\n<h3>How you can make an impact</h3>\n\nWriting tests and making them work is in itself a tough task to do, so writing one test for a single function counts and makes a big difference over the long term. Don't hesitate. Start writing tests now. A single, new test is worthy of raising a pull request and will get you well on your way to learning much more about Golang, Docker, Kubernetes, and Clouds.\n<ul>\n    <li><a href=\"https://codecov.io/gh/meshery/meshery/\">Codecov</a> is used to check code coverage in <code>mesheryctl</code> (login with GitHub to get an in-depth idea of lines-of-code being covered in code coverage).</li>\n    <li>You can check the files on CodeCovâ€™s website to figure out which mesheryctl commands havenâ€™t been covered by existing tests.</li>\n    <li>Guide: <a href=\"https://docs.google.com/document/d/1xRlFpElRmybJ3WacgPKXgCSiQ2poJl3iCCV1dAalf0k/edit#heading=h.rzpmb66db1sq\">Writing tests for mesheryctl</a>. This guide will briefly introduce how tests are supposed to be written for mesheryctl.</li>\n    <li>Contributing to Tests doesnâ€™t always mean writing new tests, It also means improving the effectiveness of already written-ones.</li>\n    <li> Search for Issues marked with area/tests in <a href=\"https://github.com/meshery/meshery\">GitHub - meshery/meshery</a>: Meshery, the cloud native management plane.</li>\n</ul>\n\nThe impact that you make with by writing even a single test is quite high. Your tests will be executed and used time-and-time again. I canâ€™t explain in words (I donâ€™t have that good of a vocabulary). Your Tests are going to run in each pull request raised against the Meshery project, in each commit someone pushes to a pull request, in every nightly regression test suite, in every release. Just think: if another contributor incidently introduces a defect or doesn't consider for an edge case, and fails to uphold the intended behavior of the code, your tests are going to catch them redhanded. How cool is that?\nSo, what are you waiting for? Jump in and write a few tests today! When you raise your pull request, label it with <code>area/tests</code> and <code>component/mesheryctl</code> and I'll be there to review! Letâ€™s get <code>mesheryctl</code> 100% code coverage badge.\n</BlogWrapper>","frontmatter":{"title":"How to write unit and integration tests for mesheryctl","subtitle":null,"date":"January 6th, 2022","author":"Piyush Singariya","thumbnail":{"extension":"webp","publicURL":"/static/228cadb307e48d8dd59978517c9862a3/integration-test.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAADwAgCdASoUAAcAPtFUo0uwJKMhsAgCABoJaQDImC0kAAD+8jqXyPcoCEgyAAAA"},"images":{"fallback":{"src":"/static/228cadb307e48d8dd59978517c9862a3/45e9e/integration-test.webp","srcSet":"/static/228cadb307e48d8dd59978517c9862a3/0622a/integration-test.webp 750w,\n/static/228cadb307e48d8dd59978517c9862a3/56413/integration-test.webp 1080w,\n/static/228cadb307e48d8dd59978517c9862a3/28a59/integration-test.webp 1366w,\n/static/228cadb307e48d8dd59978517c9862a3/45e9e/integration-test.webp 1882w","sizes":"100vw"},"sources":[]},"width":1,"height":0.35281615302869285}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/228cadb307e48d8dd59978517c9862a3/integration-test.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAADwAgCdASoUAAcAPtFUo0uwJKMhsAgCABoJaQDImC0kAAD+8jqXyPcoCEgyAAAA"},"images":{"fallback":{"src":"/static/228cadb307e48d8dd59978517c9862a3/f82b7/integration-test.webp","srcSet":"/static/228cadb307e48d8dd59978517c9862a3/3b9b0/integration-test.webp 125w,\n/static/228cadb307e48d8dd59978517c9862a3/6c123/integration-test.webp 250w,\n/static/228cadb307e48d8dd59978517c9862a3/f82b7/integration-test.webp 500w,\n/static/228cadb307e48d8dd59978517c9862a3/e30b3/integration-test.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":176}}}},"fields":{"slug":"/blog/meshery/how-to-write-unit-and-integration-tests-for-mesheryctl"}},{"id":"9e6d6d38-989d-5fb6-8743-b7b4ccc5b9b0","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport Blockquote from \"../../../../reusecore/Blockquote\";\n\nimport MeshManager from \"./mesh-manager.webp\";\nimport MesheryClients from \"./meshery-clients.webp\";\nimport Mesheryfeatures from \"./meshery-features.webp\";\nimport MesheryDeployments from \"./meshery-deployment.webp\";\nimport Nighthawk from \"./nighthawk.webp\";\nimport Patterns from \"./patterns.webp\";\nimport ServiceMeshPatterns from \"./service-mesh-patterns.webp\";\nimport Planes from \"./planes.webp\";\nimport Mesheryoperatoricon from \"../../../../assets/images/meshery-operator/meshery-operator.svg\";\nimport MesheryLogo from \"../../../../assets/images/meshery/icon-only/meshery-logo-light.svg\";\nimport NighthawkIcon from \"../../../../assets/images/nighthawk/icon-only/SVG/nighthawk-logo.svg\";\nimport PatternsLogo from \"./patterns-logo.webp\";\nimport { Link } from \"gatsby\";\n\n<BlogWrapper>\n\n<div className=\"intro \">\n\n      Meshery is the open-source, collaborative cloud native manager that can\n    configure 230+ Kubernetes infrastructure, onboard your applications, manage WebAssembly filters, apply cloud native patterns, validate against best practices, and benchmarks the performance of your cloud native deployments. Letâ€™s learn how to manage cloud native infrastructure with confidence with Meshery.{\" \"}\n\n</div>\n\n<h3>Network Planes</h3>\n<img src={Planes} className=\"slides-right\" align=\"right\" alt=\"network-planes\"/>\n  As we unfold what a management plane is, it would serve us well to talk about\n  network planes in this regard. Architecturally, a service mesh consists of two\n  planes. One of those is the data plane, while the other one is the control\n  plane. A service mesh data plane is the collection of intelligent proxies that\n  operate in unison under the coordination of the control plane. The control\n  plane performs configuration management of these intelligent proxies.\n  A management plane can do many things. Essentially, a management plane helps\n  you integrate cloud native infrastructure into your backend systems. A robust management\n  plane allows you to take full advantage of the power of the network while\n  integrating your service delivery processes seamlessly. Your management plane\n  might federate different types of infrastructure, help you instigate chaos\n  through controlled experiments, or offer automated traffic splitting in order\n  to execute different styles of canarying of your applications. Your management\n  plane might offer deep insights into the performance of your applications and\n  to the performance of your infrastructure or might deliver a change in\n  management framework.\n<h3>\n  <img\n    src={MesheryLogo}\n    align=\"center\"\n    alt=\"meshery-logo\"\n    height=\"35rem\"\n    width=\"35rem\"\n    style={{paddingBottom:\"5px\", paddingTop:\"auto\"}}/>{\" \"}\n  Meshery\n</h3>\n\n<img\n  src={MeshManager}\n  className=\"slides-left\"\n  align=\"right\"\n  alt=\"mesh-manager\"/>\n  <Link to=\"/cloud-native-management/meshery\">Meshery</Link> manages the\n  lifecycle of infrastructure. Meshery does workload management, helps you\n  onboard or offboard your applications onto the mesh. It also lets you do\n  performance management.{\" \"}\n  <a href=\"https://docs.meshery.io/concepts/architecture/meshsync\">MeshSync</a>,\n  a custom controller within{\" \"}\n  <Link to=\"/cloud-native-management/meshery/meshery-operator\">Meshery operator</Link>\n  , performs discovery of existing infrastructure and deep fingerprinting of the\n  specific functions that version of your infrastructure is capable of performing.\n  Through MeshSync, Meshery supports brownfield deployments of your infrastructure\n  (Meshery discovers your existing infrastructure deployment that is already running\n  inside your cluster(s) whether those infrastructures were deployed by Meshery or\n  not){\" \"}\n  In order to facilitate such a deep level of understanding of each type of\n  infrastructure, <Link to=\"/cloud-native-management/meshery\">Meshery</Link> has\n  models that are specific to each infrastructure (given that each infrastructure\n  has its own set of features). Consequently, in order to leverage the maximum\n  functionality of each infrastructure, Meshery has separate, dedicated adapter\n  for each of the{\" \"}\n<a href=\"https://docs.meshery.io/getting-started/overview\"> supported models. </a>\n  :{\" \"}\n<table className=\"table-1\" align=\"center\">\n  <thead>\n    <tr>\n      <th align=\"left\">Infrastructure</th>\n      <th className=\"status\">Status</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/consul\"> Meshery Adapter for Consul </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/istio\"> Meshery Adapter for Istio </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/kuma\"> Meshery Adapter for Kuma </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/linkerd\"> Meshery Adapter for Linkerd </a>{\" \"}\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/nsm\"> Meshery Adapter for Network Service Mesh </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/osm\"> Meshery Adapter for Open Service Mesh </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/traefik-mesh\"> Meshery Adapter for Traefik Mesh </a>\n      </td>\n      <td className=\"status\">stable</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/cpx\"> Meshery Adapter for Citrix Service Mesh </a>\n      </td>\n      <td className=\"status\">beta</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/nginx-sm\"> Meshery Adapter for NGINX Service Mesh </a>\n      </td>\n      <td className=\"status\">beta</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/app-mesh\"> Meshery Adapter for App Mesh </a>\n      </td>\n      <td className=\"status\">alpha</td>\n    </tr>\n    <tr>\n      <td>\n<a href=\"https://docs.meshery.io/service-meshes/adapters/tanzu-sm\"> Meshery Adapter for Tanzu Service Mesh </a>\n      </td>\n      <td className=\"status\">alpha</td>\n    </tr>\n  </tbody>\n</table>\n\n  <Link to=\"/cloud-native-management/meshery\">Meshery</Link> also lets you\n  integrate your Prometheus and Grafana add-ons so you can import your existing\n  Grafana dashboards to Meshery. When you first start Meshery, we also have a\n  configuration wizard, which basically walks you through the entire setup to\n  get Meshery up and running. By the end of this, it will make sure that you\n  have Meshery running on your cluster.\n<img\n  src={MesheryDeployments}\n  className=\"slides-right\"\n  align=\"right\"\n  alt=\"meshery-deployment\"/>\n  If you want a more finer configuration, you can configure your environment\n  through settings and you can configure infrastructure, and you can configure\n  the metrics, you can define your performance tests to be reused.\n  For configuration management,{\" \"}\n  <Link to=\"/cloud-native-management/meshery\">Meshery</Link> will analyze your\n  runtime environment for certain infrastructure and tell you if you're doing\n  things right or not. What you can do is you can upload your applications\n  directly into Meshery, edit them in the Meshery UI itself and actually apply\n  these applications or onboard these applications on your infrastructure.\n<h3>\n  <img\n    src={Mesheryoperatoricon}\n    align=\"center\"\n    alt=\"meshery-operator-logo\"\n    height=\"32rem\"\n    width=\"32rem\"\n    style={{paddingBottom:\"5px\", paddingTop:\"auto\"}}/>{\" \"}\n  Meshery Operator\n</h3>\n<img\n  src={Mesheryfeatures}\n  className=\"slides-left\"\n  align=\"right\"\n  alt=\"Meshery-features\"/>\n\n  <Link to=\"/cloud-native-management/meshery/meshery-operator\">Meshery operator</Link>{\" \"}\n  is a custom controller called MeshSync. MeshSync helps keep Meshery apprised\n  of the various changes that are going on to the infrastructure and various\n  changes that are happening within Kubernetes itself. In this way Meshery\n  supports not only greenfield deployments like deploying infrastructure itself,\n  it also supports connecting to existing infrastructure deployments, that is,\n  brownfield deployment. So it will discover your existing deployments as well.\n  There's an extensible concept in Meshery called a{\" \"}\n  <a href=\"https://docs.meshery.io/extensibility/providers\">provider</a>.\n  Providers can typically offer a layer of persistence so to the extent that\n  users are running performance tests intensely or to the extent that users want\n  to have a particular type of directory integrated to bring their own identity\n  to Meshery and have a multi-user experience. The other area of extensibility\n  is the notion that Meshery has a couple of APIs both â€“ rest API and graphql\n  API. It comes with a command-line interface as well as a user interface.{\" \"}\n<h3>Layer5 MeshMap</h3>\n  Another capability of Meshery that is going to be released in the upcoming\n  version is visually configuring your infrastructure using MeshMap. You can add\n  filters, applications as well as make other configurations visually here and\n  you can export it as patterns to make it reusable quite easily. It\n  automatically figures out the sample application we have deployed, then\n  generates a visual representation. It provides users the ability to design\n  infrastructure, infrastructure configuration, and the applications that run on\n  it.\n<img src={Patterns} className=\"slides-left\" align=\"right\" alt=\"Patterns\"/>\n<h3>\n  <img\n    src={PatternsLogo}\n    align=\"center\"\n    alt=\"patterns-logo\"\n    height=\"35rem\"\n    width=\"32rem\"\n    style={{paddingBottom:\"5px\", paddingTop:\"auto\"}}/>{\" \"}\n  Patterns\n</h3>\n  {\" \"}\n  A pattern is capable of describing the deployment of any of the meshes that Meshery\n  supports as well as the configuration of the mesh. It also notes ongoing behavior\n  so if you wanted to run a canary you can describe that in a pattern. So, patterns\n  are like a template, they're customizable and ingestible into Meshery itself.\n<img\n  src={ServiceMeshPatterns}\n  className=\"slides-right\"\n  align=\"right\"\n  alt=\"Service-Mesh-Patterns\"/>\n  Meshery will take action based on what you've described in the pattern, things\n  like generating or running a performance test, generating load, and then doing\n  statistical analysis on that set of results. In the future, if you want to\n  deploy a web assembly filter, you can describe that in a pattern as well and\n  have Meshery apply it. The patterns are infrastructure agnostic, they're\n  reusable and the initial set of them is being stored in a public-facing\n  repository. There are almost 60 patterns that have been identified.\n  Ultimately, it will allow you to ingest these and measure then orchestrate and\n  apply them to your infrastructure. You can also use Meshery to visually\n  represent them and to visually design.\n<h3>\n  <img\n    src={NighthawkIcon}\n    align=\"center\"\n    alt=\"nighthawk-logo\"\n    height=\"35rem\"\n    width=\"35rem\"\n    style={{paddingBottom:\"5px\", paddingTop:\"auto\"}}/>{\" \"}\n  Nighthawk\n</h3>\n  Thereâ€™s a project called <Link to=\"/projects/nighthawk\">Nighthawk</Link> that\n  helps advance the existing integration of nighthawk and Meshery. Nighthawk is\n  a load generator that is an envoy project. It's written in c plus plus and has\n  a couple of intriguing capabilities that are the ongoing study within\n  Nighthawk. There is an ongoing effort to take advantage of nighthawkâ€™s\n  adaptive load controllers, add a couple of those in and expose them through\n  Meshery to let people recursively evaluate what is ultimately an optimal\n  configuration in your environment and the infrastructure.\n<img src={Nighthawk} className=\"slides-right\" align=\"right\" alt=\"Nighthawk\"/>\n\n  If you consider that you've got a certain SLO or a certain minimum latency\n  requirement that you need to stick to that but you also want to at the same\n  time maximize resiliency characteristics of your deployment, that can be a\n  difficult thing to figure out particularly if any of your infrastructure\n  changes:\n<ul>\n  <li>if you add another node to your environment, your clusters,</li>\n  <li>if you upgrade your infrastructure,</li>\n  <li>if you change the configuration of your infrastructure,</li>\n  <li>\n    if you add another service to your set of workloads that you're running.\n  </li>\n</ul>\n  If these factors change, so does the ability to run optimization routines. To\n  help you identify the optimal configuration of your infrastructure but in accordance\n  with your own constraints is again the study of{\" \"}\n  <Link to=\"/projects/nighthawk\">Nighthawk</Link>.{\" \"}\n<h3>\n  Check out the CNCF On-Demand Webinar:{\" \"}\n  <Link to=\"/cloud-native-management/meshery\">Meshery</Link> - The Cloud Native\n  Manager to learn more!\n</h3>\n<div className=\"iframe-container\">\n\n  <iframe\n    width=\"460\"\n    height=\"215\"\n    src=\"https://www.youtube.com/embed/mU8qHUGYsk8\"\n    loading=\"lazy\"\n    title=\"YouTube video player\"\n    frameborder=\"0\"\n    allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n    allowfullscreen\n  ></iframe>\n\n</div>\n\n</BlogWrapper>","frontmatter":{"title":"An Introduction to Meshery (Webinar-on-Demand) ","subtitle":null,"date":"October 9th, 2021","author":"Debopriya Bhattacharjee","thumbnail":{"extension":"webp","publicURL":"/static/28ae2a6f951a849aa29443d8f5f79f4e/meshery-webinar.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRmwAAABXRUJQVlA4IGAAAABQAwCdASoUAAsAPtFipk0oJiOiMAgBABoJZgCw7GlXTbijAAD+0jMMBfop23C2fGXyMOcvtj4R0cAWOYI9rXbL4gq6+9RFfodXXX946n/c7bfC7T9i6EDDw4DwHhsAAAA="},"images":{"fallback":{"src":"/static/28ae2a6f951a849aa29443d8f5f79f4e/847c8/meshery-webinar.webp","srcSet":"/static/28ae2a6f951a849aa29443d8f5f79f4e/06597/meshery-webinar.webp 750w,\n/static/28ae2a6f951a849aa29443d8f5f79f4e/847c8/meshery-webinar.webp 810w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5641975308641975}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/28ae2a6f951a849aa29443d8f5f79f4e/meshery-webinar.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRmwAAABXRUJQVlA4IGAAAABQAwCdASoUAAsAPtFipk0oJiOiMAgBABoJZgCw7GlXTbijAAD+0jMMBfop23C2fGXyMOcvtj4R0cAWOYI9rXbL4gq6+9RFfodXXX946n/c7bfC7T9i6EDDw4DwHhsAAAA="},"images":{"fallback":{"src":"/static/28ae2a6f951a849aa29443d8f5f79f4e/6e8bd/meshery-webinar.webp","srcSet":"/static/28ae2a6f951a849aa29443d8f5f79f4e/9299f/meshery-webinar.webp 125w,\n/static/28ae2a6f951a849aa29443d8f5f79f4e/81c3e/meshery-webinar.webp 250w,\n/static/28ae2a6f951a849aa29443d8f5f79f4e/6e8bd/meshery-webinar.webp 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":282}}}},"fields":{"slug":"/blog/meshery/an-introduction-to-meshery-webinar-on-demand"}},{"id":"6d660fe4-6dc6-5b5a-80b1-ea41cc92dfff","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport { MeshkitMesheryAdapterLib } from \"./MeshkitMesheryAdapterLib.style\";\nimport { Link } from \"gatsby\";\n\nimport mesheryAdapterLibrary from \"./meshery-adapter-library.svg\";\nimport malOverview from \"./meshery-adapter-library-overview.webp\";\n\n<BlogWrapper>\n<MeshkitMesheryAdapterLib>\n\n<div className=\"intro\">The Meshery v0.5.0 release includes two new libraries: <span>MeshKit</span> and <span>Meshery Adapter Library</span>.</div>\n\nThese two libraries improve contributor experience and development speed by reducing the burden of sustaining the plethora of Meshery adapters, allowing contributors to focus on exposing any given infrastructure component's differentiated value,\ninstead of having to redundantly implement plumbing for managing cloud native infrastructure.\n\n\n## MeshKit\n\nMeshKit was formerly named `gokit` and was renamed recently to align with the other Meshery components' names (and avoid confusion with the `go-kit` project). MeshKit can be considered a derivative of `go-kit` with specific focus on cloud native management.\n\nIn the Meshery v0.5.0 release, MeshKit has been enhanced and expanded substantially. Considering that the MeshKit library provides broadly useful functionality, it is used in a growing number of Meshery components. It is intended to be one of the top level libraries in the Meshery ecosystem. <div className=\"fact\">Meshkit provides functionality useful across all Meshery components.</div>\n\nMeshKit is a toolkit for Layer5â€™s microservices, and is positioned to become Layer5â€™s middleware component for Layer5â€™s microservices, leveraging other libraries like `go-kit/kit`. In complement to functionality provided by any given cloud native infrastructure component, its purpose is to provide implementations for common cross-cutting concerns like error handling, logging, and tracing. Uniform error handling and logging across all Meshery components helps to implement efficient tooling for observability, monitoring and troubleshooting. The library provides some common data models for Meshery and Meshery's <a href=\"https://meshery.io/extensions\">ecosystem of extensions</a>.\n\nAnother central component in Meshkit is the `utils` package.\n\nThis package provides a Kubernetes and a Helm client that implements functionality based on the Go libraries of these tools. The API exposed by these libraries is quite low-level, and the higher-level functions of the `utils` package simplifies usage of Kubernetes and Helm clients significantly.\nAnother advantage MeshKit that it is not necessary to use the command line versions of these tools, providing a more tailored experience for developers,\nand better logging and error handling integration.\n\n<Link to=\"https://github.com/layer5io/meshkit\">MeshKit</Link> is simple and straight\nforward to use, as the following code example illustrates.{\" \"}\n\n```go\npackage main\n\nimport (\n\t\"os\"\n\n\tmeshkitlogger \"github.com/layer5io/meshkit/logger\"\n\tmeshkitkubernetes \"github.com/layer5io/meshkit/utils/kubernetes\"\n\t\"k8s.io/client-go/kubernetes\"\n)\n\nfunc main() {\n\t// nginx contains the deployment manifest for nginx.\n\tnginx := `apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n  replicas: 2 # tells deployment to run 2 pods matching the template\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\n`\n\n\t// Create an instance of the meshkit logger handler.\n\tlog, err := meshkitlogger.New(\"ExampleApp\",\n\t\tmeshkitlogger.Options{Format: meshkitlogger.JsonLogFormat, DebugLevel: false})\n\tif err != nil {\n\t\tos.Exit(1)\n\t}\n\tlog.Info(\"successfully instantiated meshkit logger\")\n\n\t// Detect kubeconfig on the local system.\n\tconfig, err := meshkitkubernetes.DetectKubeConfig()\n\tif err != nil {\n\t\tlog.Error(err)\n\t\tos.Exit(1)\n\t}\n\tlog.Info(config.Host)\n\n\t// Create Kubernetes client set for the detected kubeconfig using the Kubernetes Go client library.\n\tclientset, err := kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\tos.Exit(1)\n\t}\n\n\t// Create an instance of the meshkit Kubernetes client ...\n\tclient, err := meshkitkubernetes.New(clientset, *config)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\tos.Exit(1)\n\t}\n\n\t// ... and use it to deploy nginx to the cluster.\n\terr2 := client.ApplyManifest([]byte(nginx), meshkitkubernetes.ApplyOptions{\n\t\tNamespace: \"default\",\n\t\tUpdate:    true,\n\t\tDelete:    false,\n\t})\n\tif err2 != nil {\n\t\tlog.Error(err2)\n\t\tos.Exit(1)\n\t}\n\tlog.Info(\"successfully applied the manifest\")\n}\n```\n\n## Meshery Adapters\n\nMeshery adapters are management plane components and manage the lifecycle of cloud native infra. This includes installation and deletion, configuration, and verification that an installation follows recommended practices. As example use of Meshery adapters is for purposes of compliance verification, actively attesting whether whether infrastructure complies to an open standard, like that of <Link to=\"/blog/announcements/a-standard-interface-for-service-meshes\">Service Mesh Interface</Link>. Meshery adapters support management of multiple versions of their respective capabilites and also come bundled with sample applications that can be deployed for easy and quick exploration of infrastructure (or other) capabilities. <div className=\"fact\">Meshery adapters extend Meshery's core functionality housed within Meshery Server, often deepening Meshery's ability to manage the lifecycle infratructure, but not limited to those use cases. Adapters have been known to act as engineering workflow facilititors, providing gate reviews, sending emails, and so on.</div>\n\nA Meshery adapter is a gRPC server that exposes the `MeshServiceServer` interface:\n\n```go\n// MeshServiceServer is the server API for MeshService service.\ntype MeshServiceServer interface {\n\tCreateMeshInstance(context.Context, *CreateMeshInstanceRequest) (*CreateMeshInstanceResponse, error)\n\tMeshName(context.Context, *MeshNameRequest) (*MeshNameResponse, error)\n\tApplyOperation(context.Context, *ApplyRuleRequest) (*ApplyRuleResponse, error)\n\tSupportedOperations(context.Context, *SupportedOperationsRequest) (*SupportedOperationsResponse, error)\n\tStreamEvents(*EventsRequest, MeshService_StreamEventsServer) error\n}\n```\n\n- `CreateInstance` sets up the Kubernetes client. It does not, as the name might imply, create an instance of an infrastructure component.\n- `Name` returns the name of the infrastructure component, configured in the adapter.\n- `SupportedOperations` returns all supported operations, configured in the adapter. An operation is e.g. the installation of any given cloud native infrastructure component or service.\n- `ApplyOperation` executes the operation specified in the request. It is one of the supported operations.\n- `StreamEvents` allows sending events from the server to the client.\n\nThis API is one of the extension points of Meshery, making it easy to add support for new cloud native technologies to Meshery. Meshery adapters abstract away differences in installation and configuration of the various technologies. Various cloud native technologies are installed and configured in their own way. For instance, some projects have their own installer, like `istioctl` for Istio, while others use Helm charts, like Consul. One of the purposes of Meshery adapters is to abstract these differences away. <div className=\"fact\">It's important to note, however, that Meshery Adapters allow Meshery to interface with each managed system uniquely, and not treat those systems uniformly by only offering the lowest common denominator of functionality, but instead by exposing that system's differentiated value to users.</div>\n\n\n\n## Meshery Adapter Library\n\nAs can be expected, adapters for the various meshes have a lot of code in common. Initially, this common code was copied from one adapter implementation to the next. The question arose whether common code should be factored out to one or several libraries. After some discussion, the community decided to move some of the more general code to Meshkit, and adapter specific code to a new library.\n\nThus, the Meshery Adapter Library was born.\n\nIt reduces the amount of boilerplate code in the adapters substantially, making adapter code easier to follow. This is especially valuable in an open source community where typically many developers contribute, for varying amounts of time. For the same reasons, it is important such libraries are easily understandable.\n\nAlso, it means new adapters can be implemented quickly, as only configuration and operations that differ between services meshes need to be implemented.\n\n<div className=\"fact\">\n  The Meshery Adapter Library provides a common and consistent set of\n  functionality that Meshery adapters use for managing the lifecycle of\n  cloud infrastructure and their workloads.\n</div>\n\nThe initial commit was submitted on October 6th, 2020 based on a refactoring effort in the adapter for the Kuma service mesh. Within a few months, several adapters have been refactored or implemented from scratch based on the Meshery Adapter Library.\n\nThe main purpose of the Meshery Adapter Library is to:\n\n- provide a set of interfaces, some with default implementations, to be used and extended by adapters.\n- implement cross-cutting concerns like logging, error handling, and tracing.\n- provide a mini framework implementing the gRPC server that allows plugging in the mesh specific configuration and operations implemented in the adapters.\n\nThe core interface in the library is the adapter `Handler` interface:\n\n```go\n// Interface Handler is extended by adapters, and used in package api/grpc that implements the MeshServiceServer.\ntype Handler interface {\n\t// GetName returns the name of the adapter.\n\tGetName() string\n\t// CreateInstance instantiates clients used in deploying and managing mesh instances, e.g. Kubernetes clients.\n\tCreateInstance([]byte, string, *chan interface{}) error\n\t// ApplyOperation applies an adapter operation. This is adapter specific and needs to be implemented by each adapter.\n\tApplyOperation(context.Context, OperationRequest) error\n\t// ListOperations list all operations an adapter supports.\n\tListOperations() (Operations, error)\n\n\t// Need not implement this method and can be reused\n\tStreamErr(*Event, error) // Streams an error event, e.g. to a channel\n\tStreamInfo(*Event)       // Streams an informational event, e.g. to a channel\n}\n```\n\nIt corresponds closely to the gRPC API discussed above, and indeed these methods are called in the implementation of the `MeshServiceServer` interface. This implementation is also part of the Meshery Adapter Library.\n\nUsing `struct` embedding, an adapter extends the default implementation `Adapter` of the interface `Handler` from the library.\nUsually, it is sufficient that this adapter handler overrides only the `ApplyOperation` function from the default implementation.\n(There, it is a no-op implementation.)\n\nThe figure below illustrates this and the usage of the library in an adapter.\n\n<img\n  src={mesheryAdapterLibrary}\n  className=\"image-center\"\n  alt=\"meshery adapter library\"\n/>\n\nIn the `main` package of the adapter, the default configuration provider `Viper` from the library is instantiated, and reads the adapter specific configuration. This includes a specification of all available operations. As configuration providers are implementations of an interface, you can choose any of the providers from the library, or implement your own.\n\nNext, an instance of the adapter handler is created. Other components, for instance a logger, may be created depending on needs and requirements, which is symbolize by the three dots in the figure.\n\nThe `service` is a struct that holds all the parameters that specify an adapter service, like the port the gRPC server is running on, and the instance of the adapter handler created in a previous step. This struct is passed to the `Start` function from the library. This `Start` function wraps the gRPC server, wiring up all necessary components, and starts the service. The developer does not need to touch any gRPC code.\n\n### Conclusion\n\nExtracting common code from adapters to the two new libraries has proven to be a worthwhile investment. It led to cleaner code as well as cleaner application architecture, shortened implementation time for new adapters considerably, and upleveled the quality of Meshery's adapters through consistency of implementation.\n\n\n<div className=\"intro\">P.S. If these topics excite you and you want to explore the beautiful realm of cloud native infrastructure, come and say \"Hi\" on the community <Link to=\"http://slack.layer5.io\">Slack</Link> and you are sure to be warmly welcomed. <span>ðŸ˜€</span></div>\n\n</MeshkitMesheryAdapterLib>\n</BlogWrapper>\n","frontmatter":{"title":"Introducing Meshkit and the Meshery Adapter Library","subtitle":"Making the DX of cloud native infrastructure management easy.","date":"February 7th, 2021","author":"Michael Gfeller","thumbnail":{"extension":"webp","publicURL":"/static/f6d05b0291faa22eb65720f319dae9e8/meshery-adapter-library-overview.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRlIAAABXRUJQVlA4IEYAAABQAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJZwC06BuZNpYBQAD+y8x8Y+HSd5zjXtkB1x+V98O5YQD2dH+igeMC9cNeLgAA"},"images":{"fallback":{"src":"/static/f6d05b0291faa22eb65720f319dae9e8/3a03f/meshery-adapter-library-overview.webp","srcSet":"/static/f6d05b0291faa22eb65720f319dae9e8/b9516/meshery-adapter-library-overview.webp 750w,\n/static/f6d05b0291faa22eb65720f319dae9e8/2a327/meshery-adapter-library-overview.webp 1080w,\n/static/f6d05b0291faa22eb65720f319dae9e8/2a401/meshery-adapter-library-overview.webp 1366w,\n/static/f6d05b0291faa22eb65720f319dae9e8/3a03f/meshery-adapter-library-overview.webp 1920w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5614583333333334}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/f6d05b0291faa22eb65720f319dae9e8/meshery-adapter-library-overview.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRlIAAABXRUJQVlA4IEYAAABQAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJZwC06BuZNpYBQAD+y8x8Y+HSd5zjXtkB1x+V98O5YQD2dH+igeMC9cNeLgAA"},"images":{"fallback":{"src":"/static/f6d05b0291faa22eb65720f319dae9e8/cd07d/meshery-adapter-library-overview.webp","srcSet":"/static/f6d05b0291faa22eb65720f319dae9e8/46142/meshery-adapter-library-overview.webp 125w,\n/static/f6d05b0291faa22eb65720f319dae9e8/2cd09/meshery-adapter-library-overview.webp 250w,\n/static/f6d05b0291faa22eb65720f319dae9e8/cd07d/meshery-adapter-library-overview.webp 500w,\n/static/f6d05b0291faa22eb65720f319dae9e8/052d1/meshery-adapter-library-overview.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":281}}}},"fields":{"slug":"/blog/meshery/introducing-meshkit-and-the-meshery-adapter-library"}},{"id":"f0be9d0b-f557-56b6-9f99-b2d28864d4ab","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport bestPracticesSelectingElementsImg from './best-practices-selecting-elements.webp';\nimport cypressTestRunnerImg from './cypress-test-runner.webp';\n\n<BlogWrapper>\n\n<a href=\"https://www.cypress.io\" rel=\"nofollow\">Cypress</a> is the functional test tool used in development of Meshery UI. As a reliably test tool, Cypress  works with <i>ReactJS</i>, <i>VueJS</i>, <i>AngularJS</i> and so on; it is agnostic of the framework you use. You can write all types of tests: <i>end-to-end</i>, <i>integration</i>, and <i>unit tests</i>.\n\nTests allow you to ensure that the new code do not break the current one. They help you to develop and integrate new features faster and ensure everything will work after including your changes. The more tests you have, the more coverage you will have (and less likelihood of issues in production).\n\n### UI tests in Meshery\n\nMeshery has two web projects:\n\n- <b>provider-ui:</b> A <i>ReactJS</i> app that allows you to select the Provider to be used for Meshery\n- <b>ui:</b> Also a <i>ReactJS</i> app where you can do everything related with Meshery. It is the cloud native management plane.\n\nWe create UI tests for both projects using Cypress. Also, we write two types of UI tests at the moment:\n- <b>Integration:</b> Test a specific functionality without backend communication (mocking requests and responses)\n- <b>End-to-end:</b> Test a whole flow like setting up Linkerd Service Mesh or running a SMI Performance Test sending requests and validating the responses from the back-end\n\n### How to write UI tests for Meshery\n\nIf you are writting your first test, you can read and watch the <b><u><a href=\"https://docs.cypress.io/guides/getting-started/writing-your-first-test.html\">great getting started</a></u></b> from Cypress blog.\n\nThen, you have to add your test below `\"provider-ui/cypress/integration\"` or `\"ui/cypress/integration\"` folders (do not forget adding <i>_spec</i> in the filename).\n\nHere is a basic example of a test validating that <b>Provider UI component</b> exists:\n\n```javascript\ndescribe('Provider UI', () => {\n  it('renders provider component', () => {\n    cy\n      .get('[data-cy=root]')\n      .should('exist')\n  })\n})\n```\n\nPlease follow the <b><u><a href=\"https://docs.cypress.io/guides/references/best-practices.html\">best practices recommended</a></u></b> by Cypress.\nOne of the most important is to use or add the `\"data-cy\"` attribute to the element you want to interact to:\n\n<img src={bestPracticesSelectingElementsImg} className=\"image-center\" alt=\"Best Practices selecting elements with Cypress\" />\n<div style={{ textAlign: \"center\" }}>Best Practices Selecting Elements</div>\n### Run your test!\n\nOnce you have written your test, it is time to execute it locally:\n\n1. First, you have to run the back-end executing this command at the root project folder:\n\n```bash\n$ make run-local\n```\n\n2. Then, run the front-end project (i.e. provider-ui)\n\n```bash\n$ make run-provider-ui-dev\n```\n\n3. Finally, in `\"provider-ui\"` folder, run all the tests with:\n\n```bash\n$ npm run cy:run\n```\n\nIf everything went well, you will see <b>\"All specs passed!\"</b> message. Congrats!\n\nYou can also execute, debug and see in real time your test by executing:\n\n```bash\n$ npm run cy:open\n```\n\nthis will open the <b>Cypress Test Runner:</b>\n\n<img src={cypressTestRunnerImg} className=\"image-center\" alt=\"Cypress Test Runner\" />\n<div style={{ textAlign: \"center\" }}>Cypress Test Runner</div>\njust double-click on your test and a window browser will be opened and you will see your testing running!\n\n#### Whatâ€™s next?\n\nTo improve writting better tests, I recommend that you watch:\n\n- Watch the <a href=\"https://www.youtube.com/watch?v=pIFSI7xtwFs\" target=\"_blank\" rel=\"nofollow noreferrer\">Meshery Development Meeting (Nov 4th, 2020)</a> where I gave a demo running UI tests on the Meshery project (<a href=\"https://docs.google.com/presentation/d/1QbMEyQgbXMLvvSheAIDruzCFe8SmBrKXUjqP0Hxfqjw\" target=\"_blank\" rel=\"noreferrer\">slides</a>)\n- <a href=\"https://docs.cypress.io/examples/examples/tutorials.html\" rel=\"nofollow noreferrer\" target=\"_blank\">Tutorial Videos</a> from Cypress blog.\n- The <a href=\"https://www.youtube.com/watch?v=5XQOK0v_YRE\" target=\"_blank\" rel=\"nofollow noreferrer\">Brian Mann â€“ I see your point, butâ€¦ (Part 1)</a> YouTube video where he gives pro tips writting tests in Cypress.\n\nIf you have questions, do not hesitate to ask to the Meshery community on Slack :)\n\nHappy testing!\n\n\n</BlogWrapper>\n","frontmatter":{"title":"Functional Testing with Cypress in Meshery UI","subtitle":"","date":"December 16th, 2020","author":"Rodolfo Martinez Vega","thumbnail":{"extension":"webp","publicURL":"/static/b239a146858aacbc01f39092bd992e6e/cypress-logo.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRvwAAABXRUJQVlA4WAoAAAAQAAAAEwAABQAAQUxQSHkAAAAAAEuqoDAAAAAAAAAAAAAAAAAxEQBQ/v//9CkpLBwlJx4dLxU3AD0VObf/////kbOvpWm3t69rnHwCd4Rvtf////+PtK+lFbxsUslLv2CHg3ZK/f//8TCiIhoBICAgIhkpGxcHMgBDoZcqAhAAAAAAAAAAAAAAAAAAAFZQOCBcAAAAEAMAnQEqFAAGAD7RVKNLqCSjIbAIAQAaCWkAAEmNZx2QAP5J9cl7VPwN7XJEL49/xxssqNFXLSgNmwkZGlgr/sTSa2WP3E3Um5txG6RuWRpO/b5FgZ5pqOnIgAA="},"images":{"fallback":{"src":"/static/b239a146858aacbc01f39092bd992e6e/35438/cypress-logo.webp","srcSet":"/static/b239a146858aacbc01f39092bd992e6e/2b7d2/cypress-logo.webp 750w,\n/static/b239a146858aacbc01f39092bd992e6e/ab31e/cypress-logo.webp 1080w,\n/static/b239a146858aacbc01f39092bd992e6e/53ea9/cypress-logo.webp 1366w,\n/static/b239a146858aacbc01f39092bd992e6e/35438/cypress-logo.webp 1920w","sizes":"100vw"},"sources":[]},"width":1,"height":0.2833333333333333}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/b239a146858aacbc01f39092bd992e6e/cypress-logo.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRvwAAABXRUJQVlA4WAoAAAAQAAAAEwAABQAAQUxQSHkAAAAAAEuqoDAAAAAAAAAAAAAAAAAxEQBQ/v//9CkpLBwlJx4dLxU3AD0VObf/////kbOvpWm3t69rnHwCd4Rvtf////+PtK+lFbxsUslLv2CHg3ZK/f//8TCiIhoBICAgIhkpGxcHMgBDoZcqAhAAAAAAAAAAAAAAAAAAAFZQOCBcAAAAEAMAnQEqFAAGAD7RVKNLqCSjIbAIAQAaCWkAAEmNZx2QAP5J9cl7VPwN7XJEL49/xxssqNFXLSgNmwkZGlgr/sTSa2WP3E3Um5txG6RuWRpO/b5FgZ5pqOnIgAA="},"images":{"fallback":{"src":"/static/b239a146858aacbc01f39092bd992e6e/b53c0/cypress-logo.webp","srcSet":"/static/b239a146858aacbc01f39092bd992e6e/67fff/cypress-logo.webp 125w,\n/static/b239a146858aacbc01f39092bd992e6e/a643c/cypress-logo.webp 250w,\n/static/b239a146858aacbc01f39092bd992e6e/b53c0/cypress-logo.webp 500w,\n/static/b239a146858aacbc01f39092bd992e6e/bcdf5/cypress-logo.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":142}}}},"fields":{"slug":"/blog/meshery/functional-testing-with-cypress-in-meshery-ui"}},{"id":"58ae43e0-f0b0-5c61-ab4f-b71e722508cc","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport { Link } from \"gatsby\";\n\n\n<BlogWrapper>\n\n### Introduction to Meshery\n\nFor all those who are unaware of <a href=\"/meshery\">Meshery</a>, Meshery is a cloud native management plane which provides users with operational best practices, lifecycle and configuration management, but also interoperates between various infrastructure, while enabling you with the tools and knowledge to glean the most of out your infrastructure performance, while keeping your overhead to a minimum.\n\nMeshery's vision is to make the operating of any cloud infrastructure simplified. Meshery is created by the <Link to=\"/community\">Layer5</Link>.\n\nLayer5 is a community-first, Cloud Native company which has technology <Link to=\"/partners\">partnerships</Link> with various tech giants like Microsoft, CNCF, RedHat and many more to enlist. The community consists of open source leaders like maintainers of trending open-source projects, Google SoCers, Docker Captains, Cloud Native Ambassadors and many more (<a href=\"http://slack.layer5.io\">join in!</a>).\n\n\n### What is mesheryctl?\n\nMeshery provides you with a clean, robust, streamlined command-line interface to manage and benchmark your infrastructure, `mesheryctl`. With `mesheryctl`, not only you can manage your adapters & containers but you can also benchmark your mesh using the command line. `mesheryctl` provides support to a number of platforms so that we never miss out users. `mesheryctl` can be installed with a single bash command by simply executing:\n\n```bash\n$ curl -L https://meshery.io/install | PLATFORM=kubernetes bash -\n````\n\nin your terminal. You will see Meshery getting installed & fired up on port: 9081.\nYou will see the output as\n\n\n```\nExtracting mesheryctl-v0.3.14...\nArchive:  /Users/user/meshery.zip\n  inflating: LICENSE\n  inflating: README.md\n  inflating: mesheryctl\n\nInstalling mesheryctl in /usr/local/bin.\nmesheryctl installed.\npermissions moved to user\nRemoving installation files and opening Meshery...Updating Meshery now...\nPulling meshery          ... download complete\nPulling meshery-istio    ... done\nPulling meshery-linkerd  ... done\nPulling meshery-consul   ... done\nPulling meshery-octarine ... done\nPulling meshery-nsm      ... done\nPulling meshery-cpx      ... done\nPulling watchtower       ... done\n```\n\nand you will be able to see the Meshery UI on `https://localhost:9081`.\n\nIf you are wondering if bash is only way to get `mesheryctl`, then here is the list of platforms which you can get `mesheryctl` describing all the different ways to get it.\n\n<table className=\"table-1\" align=\"center\">\n<thead>\n    <tr>\n    <th align=\"left\">Platform</th>\n    <th >Supported?</th>\n    </tr>\n</thead>\n<tbody>\n    <tr>\n    <td ><a href=\"https://docs.meshery.io/installation/platforms/docker\">Docker</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - <a href=\"https://docs.meshery.io/installation/platforms/docker\">Docker - Docker App</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td><a href=\"https://docs.meshery.io/installation/platforms/kubernetes\">Kubernetes</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - <a href=\"https://docs.meshery.io/installation/platforms/aks\">Kubernetes - AKS</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - <a href=\"https://docs.meshery.io/installation/quick-start\">Kubernetes - Docker Desktop</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - <a href=\"https://docs.meshery.io/installation/platforms/eks\">Kubernetes - EKS</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - <a href=\"https://docs.meshery.io/installation/platforms/gke\">Kubernetes - GKE</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - <a href=\"https://docs.meshery.io/installation/platforms/kubernetes#helm\">Kubernetes - Helm</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - <a href=\"https://docs.meshery.io/installation/platforms/minikube\">Kubernetes - Minikube</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - Kubernetes - OpenShift</td>\n    <td className=\"text-centre\">In Progress</td>\n    </tr>\n    <tr>\n    <td><a href=\"https://docs.meshery.io/installation/quick-start\">Linux</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td><a href=\"https://docs.meshery.io/installation/quick-start\">Mac</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - <a href=\"https://docs.meshery.io/installation/mesheryctl#homebrew\">Mac - Homebrew</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td><a href=\"https://docs.meshery.io/installation/platforms/windows\">Windows</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - <a href=\"https://docs.meshery.io/installation/mesheryctl#scoop\">Scoop</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td> - <a href=\"https://docs.meshery.io/installation/platforms/windows#wsl\">WSL2</a></td>\n    <td className=\"text-centre\">âœ”ï¸</td>\n    </tr>\n    <tr>\n    <td>Raspberry Pi</td>\n    <td className=\"text-centre\">In Progress</td>\n    </tr>\n</tbody>\n</table>\n\n<br/>\nWe believe we have not missed any of the popular platforms for what itâ€™s worth, we will be rolling out support for RaspberryPi and OpenShift soon ðŸŽ‰ðŸŽ‰ðŸŽ‰.\n\nIf you are thinking about the requirements you would have to run `mesheryctl`, so to your surprise, to successfully run `mesheryctl` you will only need :\n\n<table style={{ textAlign: \"center\" }} className=\"table-box\"><tbody><tr><td className=\"text-centre\">a running Docker daemon</td></tr></tbody></table>\n\n### Into the MesheryCTL\n\nOnce you have successfully installed, you will be having the power of a new CLI Command MesheryCTL. As you type `mesheryctl` into your terminal, you will be shown with the various sub-commands and flags `mesheryctl` can support.\n\n```\nMeshery is the cloud native management plane, providing lifecycle, performance, and configuration management of cloud infrastructure and their workloads.\n\nUsage:\n  mesheryctl [command]\n\nAvailable Commands:\n  help        Help about any command\n  perf        Performance Management\n  system      Meshery Lifecyle Management\n  version     Print mesheryctl version\n\n\nFlags:\n      --config string    config file (default location is: $HOME/.meshery//meshery.yaml)\n  -h, --help            help for mesheryctl\n  -v, --version         Version of mesheryctl\n\nUse \"mesheryctl [command] --help\" for more information about a command.\n```\n\nOnce you do `mesheryctl system start`, Meshery will pull its adapters and latest docker images. Meshery will also detect your Kubernetes configuration and will let you know if Kubernetes is running. Meshery will run itâ€™s web-based user interface on localhost port `9081` and will let you select your choice of <a href=\"https://docs.meshery.io/extensibility#providers\">Provider</a> before you can start managing your infrastructure with this powerful utility.\n\n<table style={{ textAlign: \"center\" }} className=\"table-box\"><tbody><tr><td className=\"text-centre\">One of the most interesting sub-commands of <code>mesheryctl</code> is <strong><code>perf</code></strong>.</td></tr></tbody></table>\n\nThe `perf` subcommand enables you to being managing the performance of your cloud native deployment and your workloads running atop of them. It lets you benchmark your infrastructure without using the Meshery UI from the command line interface itself. Once you type `mesheryctl perf`, it will present you with all the powerful flags you can control with CLI, including providing it with a `--file` flag that points to any of a number of performance test profiles that you may have saved.\n\n```\nPerformance Management and Benchmarking using Meshery CLI.\n\nUsage:\n  mesheryctl perf --[flags]\n\nAvailable Flags for Performance Command:\n  name[string]                  (optional) A short descriptor to serve as reference for this test. If not provided, a random name will be generate.\n  url[string]                   (required) URL endpoint to send requests.\n  duration[string]              (required) Length of time to perform test (e.g 30s, 15m, 1hr). See standard notation https://golang.org/pkg/time/#ParseDuration\n  load-generator[string]        (optional) Name of load generator to be used to perform test (default: \"fortio\")\n  provider[string]              (required) Choice of Provider (default: \"Meshery\")\n  concurrent-requests[string]   (optional) Number of parallel requests to be sent (default: \"1\")\n  qps[string]                   (required) Queries per second (default: \"0\")\n  file[string]                  (optional) file containing SMPS-compatible test configuration. \n  help                          Help for perf subcommand\n\nurl, duration, concurrent-requests, and qps can be considered optional flags if specified through an SMPS compatible yaml file using --file\n```\n\nAn example usage of `mesheryctl perf --[flags]` can be\n\n```bash\n mesheryctl perf --name \"a quick stress test\" --url http://192.168.1.15/productpage --qps 300 --concurrent-requests 2 --duration 30s --token \"provider=Meshery\"\n```\n\nYou can also provide a SMPS Configuration file with `perf` subcommand, with this file provided you will not have to specify url, duration, concurrent-requests & qps. However, if specified the value provided through file will be over-rided by value through CLI. For more info about file configuration, see [here](https://github.com/service-mesh-performance/service-mesh-performance/blob/master/docs/assets/spec/readme/service%20mesh%20performance%20specification%20result.yaml).\n\n```bash\n mesheryctl perf --name \"a quick stress test\" --file {path}/smps.yaml --token \"provider=Meshery\"\n```\n\n### What's next?\n\nMeshery is an ever-growing community with attracting contributors from across the globe. We always have a role for everyone whether to be a code-writer, a community manager or a marketer. Layer5 community is always open to welcome you warmly.\n\nIf this makes you excited, [join the Layer5 community](http://slack.layer5.io) with just a click & someone will be there to make sure you do not get missed.\n\n\n</BlogWrapper>\n","frontmatter":{"title":"Getting started with mesheryctl","subtitle":"No easier way to get started with a Cloud Native","date":"May 21st, 2020","author":"Layer5 Team","thumbnail":{"extension":"webp","publicURL":"/static/9cfe96da1edeb15d9314d201d6f225a0/mesheryctl.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRj4AAABXRUJQVlA4IDIAAADwAgCdASoUAAkAPtFUo0uoJKMhsAgBABoJYwCdAC0kAAD+8Ft1agncm7Dve5aKGf5sAA=="},"images":{"fallback":{"src":"/static/9cfe96da1edeb15d9314d201d6f225a0/5711e/mesheryctl.webp","srcSet":"/static/9cfe96da1edeb15d9314d201d6f225a0/4a552/mesheryctl.webp 750w,\n/static/9cfe96da1edeb15d9314d201d6f225a0/571ff/mesheryctl.webp 1080w,\n/static/9cfe96da1edeb15d9314d201d6f225a0/1866d/mesheryctl.webp 1366w,\n/static/9cfe96da1edeb15d9314d201d6f225a0/5711e/mesheryctl.webp 1920w","sizes":"100vw"},"sources":[]},"width":1,"height":0.42552083333333335}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/9cfe96da1edeb15d9314d201d6f225a0/mesheryctl.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRj4AAABXRUJQVlA4IDIAAADwAgCdASoUAAkAPtFUo0uoJKMhsAgBABoJYwCdAC0kAAD+8Ft1agncm7Dve5aKGf5sAA=="},"images":{"fallback":{"src":"/static/9cfe96da1edeb15d9314d201d6f225a0/e4a15/mesheryctl.webp","srcSet":"/static/9cfe96da1edeb15d9314d201d6f225a0/57eec/mesheryctl.webp 125w,\n/static/9cfe96da1edeb15d9314d201d6f225a0/da46b/mesheryctl.webp 250w,\n/static/9cfe96da1edeb15d9314d201d6f225a0/e4a15/mesheryctl.webp 500w,\n/static/9cfe96da1edeb15d9314d201d6f225a0/08aed/mesheryctl.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":213}}}},"fields":{"slug":"/blog/meshery/getting-started-with-mesheryctl"}},{"id":"ee99e5c3-8e43-5eed-b3e0-a64947d39a71","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport awsappmesh from '../../../../assets/images/service-mesh-icons/aws-app-mesh.webp';\nimport consul from '../../../../assets/images/service-mesh-icons/consul.svg';\nimport istio from '../../../../assets/images/service-mesh-icons/istio.svg';\nimport linkerd from '../../../../assets/images/service-mesh-icons/linkerd.svg';\nimport maesh from '../../../../assets/images/service-mesh-icons/maesh.webp';\nimport nsm from '../../../../assets/images/service-mesh-icons/nsm.svg';\nimport octarine from '../../../../assets/images/service-mesh-icons/octarine.svg';\nimport kuma from '../../../../assets/images/service-mesh-icons/kuma.svg';\nimport {Link} from \"gatsby\"\n\n<BlogWrapper>\n\n<span className=\"starting-letter\">I</span>tâ€™s no secret that service mesh tech is boiling hot. Microservice architectures brought on as many challenges as they have advantages. With operational complexity being one of the most acute pains. Service meshes do offer solutions to a number of these operational concerns. Including but not limited to: resilience, improved observability, security and advanced service discovery.\n\n<div>\n<iframe width=\"100%\" alt=\"Deploying Linkerd with Meshery\" title=\"Deploying Linkerd with Meshery\" src=\"https://www.youtube.com/embed/MXQV-i-Hkf8\" allowFullScreen loading=\"lazy\" frameBorder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" style={{minHeight: \"315px\", minWidth: \"280px\"}}></iframe>\n</div>\n\nBut with so many mesh options around - how do we choose, evaluate and compare them? And once weâ€™ve chosen a solution - how do we make it accessible to all our engineers? It is to provide an answer to these questions that the Layer5 community has created <Link to=\"/cloud-native-management/meshery\">Meshery</Link>, the open-source, service mesh management plane. Meshery already supports a number of leading mesh providers with adapters for additional meshes on the way. In todayâ€™s video, Iâ€™ll show how to use Meshery for rolling out and evaluating Linkerd.\n\n Linkerd is a system that comes from the service mesh pioneers - the company called Buoyant. They were the first to realise the need for a distributed network of smart, centrally configured proxies and coin the term â€œservice meshâ€ back in 2016. Today, weâ€™ll be looking at Linkerd 2.x - the second generation of this now CNCF project.\n\n<h5>Meshery Adapters</h5>\n\n<table className=\"table-adapters\">\n    <thead className=\"hidden\">\n        <th>Status</th>\n        <th>Adapter</th>\n    </thead>\n    <tbody>\n    <tr>\n        <td rowspan=\"7\" className=\"stable-adapters\">stable</td>\n    </tr>\n    <tr>\n        <td><a href=\"https://github.com/layer5io/meshery-istio\"><img src={istio} alt='Istio Service Mesh adapter' className=\"adapter-logo\" />Meshery adapter for Istio</a></td>\n    </tr>\n    <tr>\n        <td><a href=\"https://github.com/layer5io/meshery-linkerd\"><img src={linkerd} alt='Linkerd' className=\"adapter-logo\" />Meshery adapter for Linkerd</a></td>\n    </tr>\n    <tr>\n        <td><a href=\"https://github.com/layer5io/meshery-consul\"><img src={consul} alt='Consul Connect' className=\"adapter-logo\" />Meshery adapter for Consul</a></td>\n    </tr>\n    <tr>\n        <td><a href=\"https://github.com/layer5io/meshery-octarine\"><img src={octarine} alt='Octarine Service Mesh' className=\"adapter-logo\" />Meshery adapter for Octarine</a></td>\n    </tr>\n    <tr>\n        <td><a href=\"https://github.com/layer5io/meshery-nsm\"><img src={nsm} alt='Network Mesh' className=\"adapter-logo\" />Meshery adapter for Network Service Mesh</a></td>\n    </tr>\n    <tr><td className=\"stable-adapters\"></td></tr>\n    <tr>\n        <td rowspan=\"2\" className=\"beta-adapters\">beta</td><td><a href=\"https://github.com/layer5io/meshery-cpx\">\nMeshery adapter for Citrix CPX</a></td>\n    </tr>\n    <tr><td className=\"beta-adapters\"></td></tr>\n    <tr>\n        <td rowspan=\"6\" className=\"alpha-adapters\">alpha</td>\n    </tr>\n    <tr>\n        <td><a href=\"https://github.com/layer5io/meshery-maesh\"><img src={maesh} alt='Maesh Service Mesh' className=\"adapter-logo\" />Meshery adapter for Maesh</a></td>\n    </tr>\n    <tr>\n        <td><a href=\"https://github.com/layer5io/meshery-app-mesh\"><img src={awsappmesh} alt='AWS App Mesh Service Mesh' className=\"adapter-logo\" />Meshery adapter for App Mesh </a></td>\n    </tr>\n    <tr>\n        <td><a href=\"https://github.com/layer5io/meshery-kuma\"><img src={kuma} alt='Kuma Service Mesh' className=\"adapter-logo\" />Meshery adapter for Kuma</a></td>\n    </tr>\n    <tr><td></td></tr>\n    <tr><td className=\"alpha-adapters\"></td></tr>\n    </tbody>\n</table>\n\nSome things that Linkerd is known for:\n\n- Purpose-built for Kubernetes\n- Featuring custom-built, highly performant proxies written in Rust\n- Zero-config option (works out-of-the-box)\n- Network telemetry built-in (includes a pre-configured, optimised Prometheus instance)\n- Low-overhead control-plane\n- Operational simplicity (when compared to Istio, for example, even though Istio is getting better in this regard)\n\nSo what is covered in the video? More or less the following:\n\n- What service mesh tech allows us to do\n- What a typical service mesh architecture looks like\n- What Layer5 is about (<i>Lookout - it may surprise you!</i>)\n- What Meshery is. What Linkerd is.\n- How easy it is to install Meshery on your PC (be it Linux, Mac or Windows)\n- All it takes is:\n```sh\n$ curl -L https://meshery.io/install | PLATFORM=kubernetes bash -\n```\n- How Meshery connects to your Kubernetes cluster (nothing to be done if itâ€™s in your <code>kubectl config current-context</code>)\n- How to correctly install and remove Linkerd on your Kubernetes cluster using Meshery\n- How to install one of included Linkerd sample applications and verify the installation\n\nThatâ€™s quite a lot of content for a 20 minute clip. In the follow-up videos, weâ€™ll dive deeper into many of these concepts. And also show how to use Meshery with other service mesh providers.\n\nThis video is also the opening shot of Layer5's [Learn to Service Mesh](https://www.youtube.com/playlist?list=PL3A-A6hPO2IN_HSU0pSfijBboiHggs5mC) playlist, which is specifically dedicated to tutorials and webinars. If service mesh tech interests you and youâ€™re willing to learn more about it, then make sure to [subscribe to the channel](https://www.youtube.com/channel/UCFL1af7_wdnhHXL1InzaMvA?sub_confirmation=1) and watch for updates.\n\nAnd let us know if thereâ€™s any specific content you want us to create. Or maybe anything youâ€™ve created yourself and would like to share? Layer5 is all about knowledge sharing and we want to talk to you, so please [join the cloud native community](http://slack.layer5.io)!\n\nHappy meshing!\n\n</BlogWrapper>\n","frontmatter":{"title":"Deploying Linkerd with Meshery","subtitle":"","date":"March 11th, 2020","author":"Anton Weiss","thumbnail":{"extension":"webp","publicURL":"/static/af48ad5b31a3b12f8d571eea1a4f863f/Linkerd-with-Meshery.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRl4AAABXRUJQVlA4IFIAAACwAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJYgAAW41+EMeuRS5kAAD+zRR30B7IZkwg5DLpIC/9Ldd+oO3jEdv9tbLd+qeOIGpIzE1i+iJaKAAA"},"images":{"fallback":{"src":"/static/af48ad5b31a3b12f8d571eea1a4f863f/bde8a/Linkerd-with-Meshery.webp","srcSet":"/static/af48ad5b31a3b12f8d571eea1a4f863f/a66aa/Linkerd-with-Meshery.webp 750w,\n/static/af48ad5b31a3b12f8d571eea1a4f863f/bde8a/Linkerd-with-Meshery.webp 960w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5625}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/af48ad5b31a3b12f8d571eea1a4f863f/Linkerd-with-Meshery.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRl4AAABXRUJQVlA4IFIAAACwAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJYgAAW41+EMeuRS5kAAD+zRR30B7IZkwg5DLpIC/9Ldd+oO3jEdv9tbLd+qeOIGpIzE1i+iJaKAAA"},"images":{"fallback":{"src":"/static/af48ad5b31a3b12f8d571eea1a4f863f/cd07d/Linkerd-with-Meshery.webp","srcSet":"/static/af48ad5b31a3b12f8d571eea1a4f863f/46142/Linkerd-with-Meshery.webp 125w,\n/static/af48ad5b31a3b12f8d571eea1a4f863f/81c3e/Linkerd-with-Meshery.webp 250w,\n/static/af48ad5b31a3b12f8d571eea1a4f863f/cd07d/Linkerd-with-Meshery.webp 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":281}}}},"fields":{"slug":"/blog/meshery/deploying-linkerd-with-meshery"}},{"id":"cac9ddb8-17d6-5815-b6a0-3a849328003b","body":"\nimport { BlogWrapper } from \"../../Blog.style.js\";\nimport wsldockerstart from \"./wsl-docker-start.webp\";\nimport wslgrafanalogin from \"./wsl-grafana-login.webp\";\nimport wslgrafanaloginsuccess from \"./wsl-grafana-login-success.webp\";\nimport wslgrafanastart from \"./wsl-grafana-start.webp\";\nimport wslk3dstart from \"./wsl-k3d-start.webp\";\nimport wslmesherycomplete from \"./wsl-meshery-complete.webp\";\nimport wslmesherylogin from \"./wsl-meshery-login.webp\";\nimport wslmesheryloginsuccess from \"./wsl-meshery-login-success.webp\";\nimport wslmesherystart from \"./wsl-meshery-start.webp\";\n\n<BlogWrapper>\n\nDuring KubeCon EU 2019, I had the chance to discover two new softwares that simply amazed me:\n1. [Meshery](https://layer5.io/cloud-native-management/meshery), which is the multi-cluster Kubernetes management plane.\n2. [k3d](https://github.com/rancher/k3d), which is used to create a dockerized [k3s](https://k3s.io) server.\n\nAnd, what really appealed to me about both of them is that everything from the installation to the usage was just *simple!*\nAnd cream on the top, both softwares are used with or inside containers, making each ideal for a create/try/delete workflow.\n\n<h4>Environment Setup</h4>\n\nBefore we start having *real* fun with Meshery, I will quickly list the different components I used for this blog post and ensure I define what could be optional for your own setup:\n1. [Meshery](https://layer5.io/cloud-native-management/meshery)\n2. [Docker](https://docs.docker.com/install/)\n    - Docker is of course mandatory and as Meshery is based on a Compose file, which means that [docker-compose](https://docs.docker.com/compose/install/) is also mandatory.\n3. [k3d](https://github.com/rancher/k3d)\n    - k3d or any k3s/K8s cluster that you might have already configured.\n4. [WSL2](https://devblogs.microsoft.com/commandline/wsl-2-is-now-available-in-windows-insiders/)\n    - For the (few) ones who know me, my \"OS base\" is WSL2, which means that without much/any change, it should run fine for any Linux/MacOS setup.\n5. [Grafana](https://grafana.com/) *(optional)*\n    - Grafana is not mandatory however is strongly recommend. We will setup a dockerized instance, but feel free to plug Meshery with your existing instance.\n\n<h4> Nothing is taken for granted </h4>\n\nFor the sake of making the blog post around Meshery, I won't explain how to install each component and will focus only on getting k3d and Meshery working.\n\nThat said, I do not take anything for granted and as Scott Hanselman once taught me: there is no \"just have to ...\" or \"by simply doing ...\".\n\nIf you face any issue with your setup (hopefully WSL2), just let me know on [Twitter](https://twitter.com/nunixtech) or on the [Layer5 Slack channel](http://slack.layer5.io).\n\n<h4>Meshery Installation</h4>\n\nFor the following steps, I will use the Ubuntu 18.04 WSL2 distro:\n\n- Start docker and confirm it's running:\n\n```bash\nsudo service docker start\ndocker version\n```\n\n- Using Docker, install Meshery on your local machine by running the following:\n\n```bash\ncurl -L https://meshery.io/install | PLATFORM=kubernetes bash -\n```\n<a href={wsldockerstart}>\n    <img src={wsldockerstart} className=\"thumbnail\" alt=\"wsl-docker-start\" />\n</a>\n\n- Create a new k3d cluster with the <code> WSL2 IP </code>\n\n```bash\nexport mainIP=`hostname -I | awk '{ print $1 }'`\nk3d list\nk3d create --workers 3 --api-port ${mainIP}:6443\nexport KUBECONFIG=\"$(k3d get-kubeconfig --name='k3s-default')\"\nkubectl cluster-info\n```\n\n<a href={wslk3dstart}>\n    <img src={wslk3dstart} className=\"thumbnail\" alt=\"wslk3dstart\" />\n</a>\n<br/>\n- Start Meshery on the newly created cluster\n\n```bash\nmesheryctl system start\n```\n\n<a href={wslmesherystart}>\n    <img src={wslmesherystart} className=\"thumbnail\" alt=\"wslmesherystart\" />\n</a>\n- Once Meshery is fully started, login in your preferred browser using the <code>WSL2 IP</code> instead of <code>localhost</code>\n\n```bash\nexport BROWSER=/mnt/c/Firefox/firefox.exe\n$BROWSER $mainIP:9081 &\n```\n\n<a href={wslmesherylogin}>\n        <img src={wslmesherylogin} alt=\"wslmesherylogin\" />\n</a>\n<a href={wslmesheryloginsuccess}>\n    <img src={wslmesheryloginsuccess} alt=\"wslmesheryloginsuccess\" />\n</a>\n\n\n#### [Optional] More analytics with Grafana\nAs stated above, Meshery can leverage the analytics provided by Grafana. For this blog post, as everything is built from scratch. Here is the setup for a new Grafana dockerized instance.\n\nStart a new Grafana on docker instance\n\n```bash\ndocker run \\\n-d \\\n-p 3000:3000 \\\n--name=grafana \\\n-e \"GF_SERVER_ROOT_URL=http://$mainIP\" \\\n-e \"GF_SECURITY_ADMIN_PASSWORD=MesheryInstance\" \\\ngrafana/grafana\n```\n\n<a href={wslgrafanastart}>\n    <img src={wslgrafanastart} className=\"thumbnail\" alt=\"wslgrafanastart\" />\n</a>\n\n- Access the new instance with the admin password that you set in the docker environment variable\n```bash\n$BROWSER $mainIP:3000 &\n```\n\n<a href={wslgrafanalogin}>\n    <img src={wslgrafanalogin} className=\"thumbnail\" alt=\"wslgrafanalogin\" />\n</a>\n<br />\n<a href={wslgrafanaloginsuccess}>\n    <img src={wslgrafanaloginsuccess} className=\"thumbnail\" alt=\"wslgrafanaloginsuccess\" />\n</a>\n\n### An inside look\nWhile everything should run fine, it's always good to have a look at what has been deployed.\n\nIn this case, we are almost exclusively working with Docker and the \"inside look\" should look something like this:\n\n<a href={wslmesherycomplete}>\n    <img src={wslmesherycomplete} className=\"thumbnail\" alt=\"wslmesherycomplete\" />\n</a>\n\n#### Conclusion\nAs [Lee Calcote](https://twitter.com/lcalcote) put it, this is a lot of buzz words: Meshery > k3s (deployed via k3d) > Docker > WSL2 > Windows 10. And he's totally right, still the \"beauty\" here, is that it \"simply works\".\n\nSince the begin of the Docker era, new tooling has appeard for simplifying complex workflows.\nEven Kubernetes (K8s) as a much lighter version with k3s by Rancher.\n\nAnd of course, Meshery which integrates and simplifies the installation and benchmarking of different Kubernetes configurations. Hope you had fun assembling all these pieces and stay tunned for the \"Bonuses\", more fun to come!\n\n<span> > > > <i>Nunix out</i></span>\n\n\n</BlogWrapper>\n","frontmatter":{"title":"Getting started with Meshery, WSL2 and k3d","subtitle":"","date":"July 9th, 2019","author":"Nuno do Carmo","thumbnail":{"extension":"webp","publicURL":"/static/4c732e28e50f90fde2ff41201d6d0743/cnab-logo.webp","childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/webp;base64,UklGRrgAAABXRUJQVlA4IKwAAAAwBQCdASoUABQAPtFgqU+oJSOiKAgBABoJagDHMywTmwXkh8XuWw62pPgeLa6iGOkYAAD+9R4SKH1oL6udrBkwr5rrkLRIeudVijKFQQi4NBpAgn1GqiLKGll7/coQQQ8X2m4ARFICZ1eH4EKwlMH79KOgYAEP9qeZU1fXG+Jmj3mSYoA/SF+9X/WI4UZXzEZSPBXefiBldNQhjxeWdjq9FujdEnATM/mAAAAA"},"images":{"fallback":{"src":"/static/4c732e28e50f90fde2ff41201d6d0743/416c3/cnab-logo.webp","srcSet":"/static/4c732e28e50f90fde2ff41201d6d0743/416c3/cnab-logo.webp 400w","sizes":"100vw"},"sources":[]},"width":1,"height":1}}},"darkthumbnail":{"extension":"webp","publicURL":"/static/4c732e28e50f90fde2ff41201d6d0743/cnab-logo.webp","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/webp;base64,UklGRrgAAABXRUJQVlA4IKwAAAAwBQCdASoUABQAPtFgqU+oJSOiKAgBABoJagDHMywTmwXkh8XuWw62pPgeLa6iGOkYAAD+9R4SKH1oL6udrBkwr5rrkLRIeudVijKFQQi4NBpAgn1GqiLKGll7/coQQQ8X2m4ARFICZ1eH4EKwlMH79KOgYAEP9qeZU1fXG+Jmj3mSYoA/SF+9X/WI4UZXzEZSPBXefiBldNQhjxeWdjq9FujdEnATM/mAAAAA"},"images":{"fallback":{"src":"/static/4c732e28e50f90fde2ff41201d6d0743/416c3/cnab-logo.webp","srcSet":"/static/4c732e28e50f90fde2ff41201d6d0743/d8057/cnab-logo.webp 100w,\n/static/4c732e28e50f90fde2ff41201d6d0743/2e34e/cnab-logo.webp 200w,\n/static/4c732e28e50f90fde2ff41201d6d0743/416c3/cnab-logo.webp 400w","sizes":"(min-width: 400px) 400px, 100vw"},"sources":[]},"width":500,"height":500}}}},"fields":{"slug":"/blog/meshery/getting-started-with-meshery-wsl2-and-k3d"}}]}},"pageContext":{"category":"Meshery"}},"staticQueryHashes":["1485533831","4047814605","408154852","4152005505"],"slicesMap":{},"matchPath":"/blog/category/meshery"}