{"componentChunkName":"component---src-templates-learn-chapter-js","path":"/learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/fault-injection.html","result":{"data":{"chapter":{"body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"docType\": \"Chapter\",\n  \"chapterTitle\": \"Fault Injection\",\n  \"description\": \"Meshery, collaborative Kubernetes manager\",\n  \"videos\": 4,\n  \"lectures\": 12,\n  \"order\": 8\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(ChapterStyle, {\n    mdxType: \"ChapterStyle\"\n  }, mdx(\"h2\", {\n    className: \"chapter-sub-heading\"\n  }, \"Fault Injection using SMI in Linkerd\"), mdx(\"p\", null, \"Application failure injection is a form of chaos engineering where we artificially increase the error rate of certain services in a microservice application to see what impact that has on the system as a whole. Traditionally, you would need to add some kind of failure injection library into your service code in order to do application failure injection. Thankfully, the service mesh gives us a way to inject application failures without needing to modify or rebuild our services at all.\"), mdx(\"h3\", {\n    className: \"chapter-sub-heading\"\n  }, \"Using SMI Traffic Split API to inject errors\"), mdx(\"p\", null, \"We can easily inject application failures by using the Traffic Split API of the Service Mesh Interface. This allows us to do failure injection in a way that is implementation agnostic and works across service meshes.\"), mdx(\"p\", null, \"We will do this first by deploying a new service which only return errored responses. We will be using a simple NGINX service which has configured to only return HTTP 500 responses.\"), mdx(\"p\", null, \"We will then create a traffic split which would redirect the service mesh to send a sample percentage of traffic to the error service instead, let's say 20% of service's traffic to error, then we would have injected an artificial 20% error rate in service.\"), mdx(\"h3\", {\n    className: \"chapter-sub-heading\"\n  }, \"Deploy Linkerd Books Application\"), mdx(\"p\", null, \"We will be deploying \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/BuoyantIO/booksapp\"\n  }, \"Linkerd Books application\"), \" for this part of the demo\"), mdx(\"p\", null, \"Use meshery to deploy the bookinfo application :\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In Meshery, navigate to the Linkerd adapter's management page from the left nav menu.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"On the Linkerd adapter's management page, please enter \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"default\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Namespace\"), \" field.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Then, click the (+) icon on the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Sample Application\"), \" card and select \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Books Application\"), \" from the list.\")), mdx(\"p\", null, \"Inject linkerd into sample application using\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"linkerd inject https://run.linkerd.io/booksapp.yml | kubectl apply -f -\\n\")), mdx(\"p\", null, \"In the following, one of the service has already beeen configured with the error let's remove the error rate from the same :\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"kubectl edit deploy/authors\\n\")), mdx(\"p\", null, \"Remove the lines\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"- name: FAILURE_RATE\\n  value: \\\"0.5\\n\")), mdx(\"p\", null, \"Now if you will see \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"linkerd stat\"), \", the success rate would be 100%\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"linkerd stat deploy\\n\")), mdx(\"h3\", {\n    className: \"chapter-sub-heading\"\n  }, \" Create the errored service\"), mdx(\"p\", null, \"Now we will create our error service, we have NGINX pre-configured to only respond with HTTP 500 status code\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"apiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: error-injector\\n  labels:\\n    app: error-injector\\nspec:\\n  selector:\\n    matchLabels:\\n      app: error-injector\\n  replicas: 1\\n  template:\\n    metadata:\\n      labels:\\n        app: error-injector\\n    spec:\\n      containers:\\n        - name: nginx\\n          image: nginx:alpine\\n          ports:\\n          - containerPort: 80\\n            name: nginx\\n            protocol: TCP\\n          volumeMounts:\\n            - name: nginx-config\\n              mountPath: /etc/nginx/nginx.conf\\n              subPath: nginx.conf\\n      volumes:\\n        - name: nginx-config\\n          configMap:\\n            name: error-injector-config\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  labels:\\n    app: error-injector\\n  name: error-injector\\nspec:\\n  clusterIP: None\\n  ports:\\n  - name: service\\n    port: 7002\\n    protocol: TCP\\n    targetPort: nginx\\n  selector:\\n    app: error-injector\\n  type: ClusterIP\\n---\\napiVersion: v1\\ndata:\\n nginx.conf: |2\\n\\n    events {\\n        worker_connections  1024;\\n    }\\n\\n    http {\\n        server {\\n            location / {\\n                return 500;\\n            }\\n        }\\n    }\\nkind: ConfigMap\\nmetadata:\\n  name: error-injector-config\\n\")), mdx(\"p\", null, \"After deploying the above errored service, we will create a traffic split resource which will be responsible to direct 20% of the book service to the error.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"apiVersion: split.smi-spec.io/v1alpha3\\nkind: TrafficSplit\\nmetadata:\\n  name: fault-inject\\nspec:\\n  service: books\\n  backends:\\n  - service: books\\n    weight: 800m\\n  - service: error-injector\\n    weight: 200m\\n\")), mdx(\"p\", null, \"You can now see an 20% error rate for calls from webapp to books\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"linkerd routes deploy/webapp --to service/books\\n\")), mdx(\"p\", null, \"You can also see the error on the web browser\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"kubectl port-forward deploy/webapp 7000 && open http://localhost:7000\\n\")), mdx(\"p\", null, \"If you refresh page few times, you will see \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Internal Server Error\"), \".\"), mdx(\"h3\", {\n    className: \"chapter-alt-heading\"\n  }, \"Cleanup\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"kubectl delete trafficsplit/error-split\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Remove the book info application from the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Meshery Dashboard\"), \" by clicking on the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"trash icon\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sample application\"), \" card on the linkerd adapters' page.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"chapterTitle":"Fault Injection","description":"Meshery, collaborative Kubernetes manager"},"fields":{"slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/fault-injection","course":"introduction-to-service-meshes","learnpath":"mastering-service-meshes-for-developers","chapter":"fault-injection"}},"course":{"nodes":[{"frontmatter":{"courseTitle":"Introduction to Service Meshes - Hands On","meshesYouLearn":[{"imagepath":{"childImageSharp":null,"extension":"svg","publicURL":"/static/731763d720780a49c2ffdfede8c28f4b/istio.svg"},"name":"Istio"},{"imagepath":{"childImageSharp":null,"extension":"svg","publicURL":"/static/b4f4020971de42f6fb2497075a67f325/linkerd.svg"},"name":"Linkerd"}]},"fields":{"slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes"}}]},"TOC":{"nodes":[{"frontmatter":{"order":8,"chapterTitle":"Circuit Breaking"},"fields":{"section":"istio","chapter":"circuit-breaking"}},{"frontmatter":{"order":9,"chapterTitle":"Conclusion"},"fields":{"section":"istio","chapter":"conclusion"}},{"frontmatter":{"order":2,"chapterTitle":"Deploy a sample application"},"fields":{"section":"istio","chapter":"deploy-an-application"}},{"frontmatter":{"order":3,"chapterTitle":"Exposing services through Istio Ingress Gateway"},"fields":{"section":"istio","chapter":"expose-services"}},{"frontmatter":{"order":6,"chapterTitle":"Fault Injection"},"fields":{"section":"istio","chapter":"fault-injection"}},{"frontmatter":{"order":1,"chapterTitle":"Getting Started"},"fields":{"section":"istio","chapter":"getting-started"}},{"frontmatter":{"order":7,"chapterTitle":"Mutual TLS & Identity Verification"},"fields":{"section":"istio","chapter":"mutual-tls"}},{"frontmatter":{"order":4,"chapterTitle":"Observability"},"fields":{"section":"istio","chapter":"observability"}},{"frontmatter":{"order":5,"chapterTitle":"Request Routing and Canary Testing"},"fields":{"section":"istio","chapter":"routing-and-canary"}},{"frontmatter":{"order":9,"chapterTitle":"Conclusion"},"fields":{"section":"linkerd","chapter":"conclusion"}},{"frontmatter":{"order":4,"chapterTitle":"Linkerd Dashboard"},"fields":{"section":"linkerd","chapter":"dashboard"}},{"frontmatter":{"order":5,"chapterTitle":"Debugging (Optional)"},"fields":{"section":"linkerd","chapter":"debugging"}},{"frontmatter":{"order":2,"chapterTitle":"Deploy a sample application"},"fields":{"section":"linkerd","chapter":"deploy-an-application"}},{"frontmatter":{"order":3,"chapterTitle":"Exposing services through Linkerd Ingress"},"fields":{"section":"linkerd","chapter":"expose-services"}},{"frontmatter":{"order":8,"chapterTitle":"Fault Injection"},"fields":{"section":"linkerd","chapter":"fault-injection"}},{"frontmatter":{"order":1,"chapterTitle":"Getting Started"},"fields":{"section":"linkerd","chapter":"getting-started"}},{"frontmatter":{"order":6,"chapterTitle":"Observability"},"fields":{"section":"linkerd","chapter":"observability"}},{"frontmatter":{"order":7,"chapterTitle":"Traffic Splitting using SMI and Linkerd"},"fields":{"section":"linkerd","chapter":"traffic-splitting"}}]},"serviceMeshesList":{"nodes":[{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"istio"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}},{"fields":{"section":"linkerd"}}]}},"pageContext":{"learnpath":"mastering-service-meshes-for-developers","slug":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/fault-injection","course":"introduction-to-service-meshes","section":"linkerd","chapter":"fault-injection","pageType":"chapter"}},"staticQueryHashes":["3750885592","4047814605"],"slicesMap":{},"matchPath":"learn/learning-paths/mastering-service-meshes-for-developers/introduction-to-service-meshes/linkerd/fault-injection"}