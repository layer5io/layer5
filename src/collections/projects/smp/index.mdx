---
title:  "Service Mesh Performance"
subtitle: "Measuring and indexing the performance, overhead, and value of the world's service mesh deployments."
thumbnail: /assets/projects/smp/stacked/smp-white.svg
published: true
---

import { ProjectWrapper } from "../Project.style.js";
import smp from "./smp-dark.svg";
import img1 from "./native-and-wasm-at-capacity-100rps.png";
import img2 from "./latency-at-scale.png";
import img3 from "./client-capacity.png";

<ProjectWrapper>

<div>
  <img src={smp} className="image-left" />
  <div className="center">
    <h4 class="black-text center" style="font-size:1.5rem">
    Service Mesh Performance (SMP)<br /> is a vendor-neutral specification to <br />
    <strong>standardize service mesh value meausurement</strong>.
    </h4>
  </div>
</div>

<p>The Service Mesh Performance Working Group is hosted within CNCF SIG Network. All are welcome to participate. This group is defining the Service Mesh Performance (SMP). Using SMP, MeshMark provides a universal performance index to gauge your mesh’s efficiency against deployments in other organizations’ environments.</p>
<h3 class="center">SMP is a collaborative effort of Layer5, UT Austin, Google, and The Linux Foundation.</h3>

<div>
  <div style="margin: auto;">
    <p>SMP accounts for details of:</p>
    <ul class="bullet">
        <li>Environment and infrastructure details</li>
        <li>Service mesh and its configuration</li>
        <li>Service (workload) details</li>
        <li>Statistical analysis of performance results</li>
    </ul>
  </div>
  <div style="margin:auto;">
    <h2 style="text-align: center;font-weight: bold;">
    Learn more at <a href="https://smp-spec.io">smp-spec.io</a></h2>
  </div>
</div>
<p>The group is also working in collaboration with the Envoy project to create easy-to-use tooling around <a href="/projects/service-mesh-distributed-performance-management">distributed performance management</a> (distributed load generation and analysis) in context of Istio, Consul, Tanzu Service Mesh, Network Service Mesh, App Mesh, Linkerd, and so on.</p>

<div class="row" style="margin: auto;">
  <div class="col" style="text-align: center; position: relative;">
    <iframe
      width="100%" height="320px" src="https://www.youtube.com/embed/LxP-yHrKL4M"
      frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen>
    </iframe>
    <p><i>Learn more about the cost of a service mesh</i></p>
  </div>
  <div class="col" style="text-align: center; position: relative;">
    <iframe
      src="https://docs.google.com/presentation/d/e/2PACX-1vSWhREOZIfJqTG8jHtitgb5e-OAHC7E8EMmoVCaTRmC8b_itHkeFUNKcBVn9oaTpX5ozYvlhscvBXiK/embed?start=false&loop=false&delayms=3000"
      frameborder="0" width="100%" height="320" allowfullscreen mozallowfullscreen="true"
      webkitallowfullscreen="true">
      </iframe>
      <p><i>Participate in the CNCF Service Mesh Performance Working Group</i></p>
  </div>
</div>



<div style="display: flex; justify-content:center;">
  <h4 class="black-text center" style="font-size: 1.5rem;">
    Discreetly Studying the Effects of Individual Traffic Control Functions
    <div class="responsive-holder" style="margin-top: 20px;">
    <iframe class="responsive-iframe" style="margin: auto;" width="560" height="315" src="https://www.youtube.com/embed/rgnb0-ntPko"
      frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"allowfullscreen>
    </iframe>        
    </div>
  <p style="font-size: 1rem;"><i>KubeCon EU 2020 - Lee Calcote & Prateek Sahu</i></p>
  </h4>
</div> 
            
<div>
  <h5 class="black-text">Performance of Envoy Filters</h5>
  The following analysis compares native Envoy filter performance to WebAssembly (WASM) filter performance using Rust.
  <br /><br />
  <div class="row">
    <div class="col">
      <a href="/assets/projects/smp/kubecon-eu/native-and-wasm-at-capacity-100rps.png">
        <img src={img1}
          class="light-shadow" style="margin: auto; min-width: 300px; height: 300px;" />
      </a>
    </div>
    <div class="col">
      <b>Native WASM at Capacity:</b> <br />
      When every request goes via the
      rate-limit check and then the actual program logic, we see that
      the latency incurred for the WASM code is higher than the Native
      client. This is expected since the native client has processing
      for rate-limiting locally in a process whereas the rust module
      is invoked as an additional thread to do the processing and the
      communication involved with the module incurs an overhead. This
      is prominent in the minimum response time case which represents
      latency just due to rate-limiting logic where every other part
      of the request is already "warm". As we move towards average
      latency, the overhead gets slightly amortized but is still above
      the native rate-limiting case. Our max latency is slightly lower
      than native, but we attribute it to various other system effects
      like TLS handshake and network latencies that usually contribute
      to the maximum tail latency.
    </div>
  </div>
  <br />< br/>
  <div class="row">
    <div class="col">
    <a href="/assets/projects/smp/kubecon-eu/latency-at-scale.png">
      <img src={img2}
      class="light-shadow" style=" margin: auto; min-width: 300px; height: 300px;" />
    </a>
    </div>
    <div class="col">
    <b>Latency at scale:</b><br />
    When we go beyond the
    application capacity (100 in our example), we start noticing the
    power of a in-line ight wasm module which starts terminating
    requests at the side-car and the core application logic is never
    invoked/loaded. We notice that even the minimum response time
    for a terminated request is about 15-20% faster than invoking of
    application logic since the wasm is a dynamic module in the
    sidecar and we start to avoid complex network redirection and
    invocation of a new container/instance. We also notice that the
    average latency of requests is lower than in the case of native
    client.
    </div>
  </div>
  <br /><br />
  <div class="row">
    <div class="col">
      <a href="/assets/projects/smp/kubecon-eu//client-capacity.png">
        <img src={img3}
        class="light-shadow" style="margin: auto; height: 300px;" />
      </a>
    </div>
    <div class="col">
      <br /><b>Client Capacity:</b><br />
      Client Capacity figure also shows us that we are able to handle
      more requests than in the native case, although this infometric
      needs to be taken with a grain of salt, i.e. the difference
      might reduce if our application capacity was significantly
      larger than 100.
    </div>
  </div>
</div>

<br />
<div class="row">
  <div class="col">
    <blockquote class="twitter-tweet">
      <p lang="en" dir="ltr">
        Learn more about the service mesh performance initiatives at
        <a href="https://twitter.com/layer5?ref_src=twsrc%5Etfw">@layer5</a>
        <a href="https://t.co/hNUM4pHDqi">https://t.co/hNUM4pHDqi</a>
      </p>
      &mdash; Service Mesh Performance (@smp_spec)
      <a href="https://twitter.com/smp_spec/status/1290428583249354757?ref_src=twsrc%5Etfw">August 3, 2020</a>
    </blockquote>
  </div>

  <div class="col" style="vertical-align: bottom; margin: auto; padding-top: 100px;">
    <h3 style="text-align: center; font-weight: bold;">
      Jump into the
      <a href="http://slack.layer5.io">#SMP channel</a> to learn more
      about these initatives.
    </h3>
  </div>
</div>

</ProjectWrapper>