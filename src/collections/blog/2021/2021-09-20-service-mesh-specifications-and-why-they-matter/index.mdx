---
title: "Service Mesh Specifications and Why They Matter"
date: 2021-09-20 10:30:05 -0530
author: Debopriya Bhattacharjee
thumbnail: ./Cover-image.png
darkthumbnail: ./Cover-image.png
category: "Service Mesh Specifications"
tags:
 - Projects
 - SMI
 - SMP
published: true
resource: true
type: Blog
product: Service Mesh Performance
---

import { BlogWrapper } from "../../Blog.style.js";
import Blockquote from "../../../../reusecore/Blockquote";

import Hamlet from "./Hamlet.png";
import Graph from "./Graph1.png";
import Bucket from "./Graph2.png";
import SMI from "./SMI-demo.png";
import SMP from "./SMP.png";
import Abstractions from "./abstractions.png";
import Journey from "./cloud-native-journey.png";
import Flowchart from "./flowchart.png";
import { Link } from "gatsby";


<BlogWrapper>

<div class="intro ">
  <p>
   <Link to="/community/members/lee-calcote">Lee Calcote</Link> is an innovator, product and technology leader, active in the community as a Docker Captain, Cloud Native Ambassador and GSoC, GSoD, and Community Bridge Mentor. In this talk, he walked through service mesh specifications and why they matter in your deployment.
   How many service mesh specifications do you know? He went through all of them. So, no worries if you're unfamiliar.
  </p>
</div>   

### Service Mesh Specifications:
<img src={Abstractions} className="slides-left" align="left" alt="abstractions" />

As the ubiquity of service meshes unfolds and they become a commonplace for any cloud native or edge environment, so does the need for vendor and technology-agnostic interfaces to interact with them. The Service Mesh Interface (SMI), the Service Mesh Performance (SMP), and Multi-Vendor Service Mesh Interoperation (Hamlet) are three open specifications solving the challenge of interoperability, workload and performance management between service meshes. 

Learn what makes each of them unique and why they are much needed. See each of these three specifications in action as we use Meshery, the open-source service mesh management plane to demonstrate the value and functionality of each service mesh abstraction, and the adherence of these specifications by Istio, Linkerd, Consul and other popular service meshes.

### Cloud native Journey to service meshes:

<img src={Journey} className="slides-right" align="right" alt="journey-image" />

The advent of cloud native was the popularization of containers. Thank you Docker! From there, containers took off like wildfire. Turns out you need an orchestrator to wrangle that sprawl. We saw a number of orchestrators come and we still have a number of orchestrators around.

Service meshes have become a hot topic in the last few years. They still continue to be, rightfully so, a very powerful piece of technology. “A lot of the power is yet to come from my perspective. For my part, I believe that there is a tomorrow in which data plane intelligence really matters. And matters about how people write cloud native applications.”, Lee emphasized. Not everyone quite understands the capabilities of meshes as they are promoted and spoken about today. So come along into the journey of service mesh.

There are a number of service meshes out there. One of the community projects is to track the landscape of all of the meshes there are. There’s a lot to say about each of them, their architecture, and their working. Why are they made? Who are they focused on? What do they do? When did they come about? Why are some of them not here anymore? Why are we still seeing new ones? A lot of things to go through. You might be interested in any number of the details that the landscape tracks.
 <div class="note">Be Aware, It's Meshy Out There!</div>

### Service Mesh Interface
<img src={SMI} className="slides-left" align="left" alt="smi-image" />
<ul>
    <li>Its goal and genesis were born inside of Kubernetes.</li>
    <li> Being a specification that is native to Kubernetes, its focus is on lowest common denominator functionality.</li>
    <li> The focus on bringing forth APIs that highlight and reinforce the most common use cases that service meshes are being used for currently</li>
    <li>Leaves space and provides extensibility room for additional APIs to address other service mesh functionality as more people adopt and make use cases well known.</li>
    <li>There are seven service meshes that claim compatibility with SMI. There's been a community effort, open-source effort to create service mesh conformance tests to assert whether or not a given service mesh is compatible with SMI</li>
    <li> In order to facilitate those types of tests, you need to have a tool to provision a sample application on those services which will generate load and test whether traffic splitting behaves as expected or works with that service mesh implementation properly.</li>
    <li>Then you need to be able to collect the results, guarantee the provenance of those results and publish them.</li>
    <li> As a community, we turned to Meshery as the tool to implement <Link to="/projects/service-mesh-interface-conformance">SMI conformance</Link> and we have been working with the individual service meshes to validate their conformance. </li>
</ul>    
<b>Meshery</b>
<ul>
  <li> We work on an open-source project called <Link to="/service-mesh-management/meshery">Meshery</Link>.</li>
  <li> Meshery, the cloud native management plane, is the canonical implementation of the service mesh performance.</li>
  <li>The management planes can do a number of things to help bridge the divide between other back-end systems and service meshes. They also help performance management, configuration management, making sure you are following best practices in your implementations by taking common patterns and applying them to your environment </li>
</ul>
Let's take a moment to demo what it looks like to validate conformance in SMI using Meshery.

<img src={Graph} className="slides-left" align="left" alt="graph" />
<ul>
   <li> We need to spin up Meshery locally</li>
   <li> We use mesheryctl as the command line interface to work with Meshery.</li>
   <li> We can interact with a number of different service mesh. The service mesh we’re going to work with today is an Open service mesh (one of those 7 that is compatible with SMI). Let’s put it to the test.</li>
   <li> We'll initiate <Link to="/projects/service-mesh-interface-conformance">SMI conformance</Link></li>
   <li>These tests go and do assertions across these different specifications. We’re looking at traffic access, traffic splitting, traffic specification. Meshery then collects these results and will eventually be publishing them in combination with the SMI project.</li>
</ul>

### Service Mesh Performance
<img src={SMP} className="slides-right" align="right" alt="smp-image" />
<ul>
    <li>Focused on describing and capturing the performance of a service mesh.</li>
    <li>The overhead of the value is another way of looking at it and characterizing it.</li>
    <li>Trying to characterize the performance of the infrastructure of a service mesh can be really difficult.</li>
    <li>Considering the number of variables that you would have to track, how difficult it can be to have repeatable tests, and benchmark your environment, to track your history based on your environment, compare performance between other meshes people need.</li>
    <li>SMP creates a standard way of capturing the performance of the mesh to help with these issues.</li>
    <li>It's also the way in which you're configuring your control plan of your service mesh.</li>
</ul>    

You might be using a client library to do some service mesh functionality. Maybe you're using those in combination with the service mesh. What costs more? What's more efficient? What's more powerful? Maybe you're using web assembly and filters there.
These are all open questions that <Link to="/projects/service-mesh-performance">SMP</Link> assists in answering in your environment. You’d be surprised by some of the results of some tests that we have done and that the community has done in combination with a couple of universities and graduate students.

<b>Performance Test</b>

Demonstration of the implementation of service mesh Performance:

<img src={Flowchart} className="slides-left" align="left" alt="flowchart" />
<ul>
  <li> On the terminal, we have a local deployment of Meshery running. You can also deploy on Kubernetes as well as the vendor Kubernetes platforms like AKS, EKS and GCP or you can use a dockerized container to run Meshery. You can also have your Kubernetes on Docker desktop.</li>
  <li>We have the Open service mesh deployed.</li>
  <li> The Meshery UI is exposed at 9081 port. This is the UI which is used to instantiate a Load test.</li>
  <li> Over here you can see we have 3 load generators fortio, wrk2, nighthawk.</li>
  <li> All of these load generators have their own set of attributes which they record correctly and each of its attributes have their own significance. We begin with fortio.</li>
  <img src={Bucket} className="slides-right" align="right" alt="graph" />

  <li> You can actually download the test results or you can just browse into the Results Tab and see all of the tests which you have run until now.</li>
  <li>Next, we used nighthawk to generate the load and benchmark the service for the same. Nighthawk is a load generator which is maintained by the Envoy community and is relatively new. It still hasn't got its 1.0 release but right now Nighthawk has sufficient features to compete with different generators which are still in the play. It can generate a gRPC service on its own and it has some more attributes which you can expose using their CLI tools.</li>
  <li> You can also see that Meshery has the capability to search your environment, see what specifications are being used and what's the load on your Kubernetes.</li>
  <li>Jump into the results Tab and see how we compare with these results.</li>
  <li>You can click on the download. You will see that a yaml gets downloaded in which you can browse and see that the start time, load time, the performance latencies, the metrics are being captured.</li>
</ul>  

### Hamlet or Multi-vendor Service Mesh Interoperation
<img src={Hamlet} className="slides-left" align="left" alt="hamlet-image" />
<ul>
  <li>Focus on service mesh federation</li>
  <li>Specifies a set of API standards for enabling service mesh federation</li>
  <li>Hamlet takes on a client-server architecture in which resources and services of one service mesh are discovered, registered and using a common format, information about them is exchanged between different service mesh.</li>
  <li>Rules around authentication and authorization rules around which Services get exposed and to whom and who can communicate with them and whether or not they can do it securely. These are things that Hamlet addresses.</li>
  <li>The specification currently consists of two APIs:
    <ul>
      <li><strong>The Federated Resource Discovery API</strong>: API to authenticate and securely distribute resources between federated service meshes.</li>
      <li>The <strong>Federated Service Discovery API</strong>: API to discover, reach, authenticate and securely communicate with federated services.</li>
    </ul>
  </li>
  <li>Part of the real power is the ability to overcome what are likely to be separate administrative domains. The intention here is to marry up connect two disparate service mesh deployments, those deployments might be of the same type, they might be of two different types.</li>
</ul>

In addition to SMI, SMP and Hamlet there has been an emergence of service mesh patterns, by which people are running and operating service meshes. There is a service mesh working group under CNCFs network that is helping identify those patterns of which there's a list right now unbeknownst to you. Reach out, join it, help us work through the 60 patterns that are defined right now. 30 of those are going into an <Link to="/learn/service-mesh-books">O’Reilly</Link> book called <Link to="/learn/service-mesh-books/service-mesh-patterns">Service Mesh Patterns</Link>.

Something that isn’t always obvious to folks is this piece of value that people get from a service mesh and actually from the specifications that we were just mentioning. It is the fact that teams are decoupled when you’re running a mesh. Developers get to iterate a bit independently of operators, and so do operators get to make changes to implement infrastructure to the way that applications behave independent of developers in the presence of a mesh.  Both of these teams are significantly empowered. Everybody gets a piece of power when they deploy a mesh.


_**P.S.: If these topics excite  come and say "Hi" on our [Slack Channel](http://slack.layer5.io) and one of us will reach out to you!**_

</BlogWrapper>
